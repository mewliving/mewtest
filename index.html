<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>ANWEM — AI 도박 시뮬레이션</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body, #root { width: 100%; height: 100%; background: #050505; overflow: hidden; touch-action: manipulation; }
  @supports (height: 100dvh) { html, body, #root { height: 100dvh; } }
  @supports (padding-top: env(safe-area-inset-top)) {
    .safe-top { padding-top: env(safe-area-inset-top) !important; }
    .safe-bottom { padding-bottom: env(safe-area-inset-bottom) !important; }
  }
  body { -webkit-text-size-adjust: 100%; }
</style>
<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;

// --- Hook: window size ---
function useIsMobile() {
  const [m, setM] = useState(typeof window !== "undefined" ? window.innerWidth < 768 : false);
  useEffect(() => {
    const h = () => setM(window.innerWidth < 768);
    window.addEventListener("resize", h); return () => window.removeEventListener("resize", h);
  }, []);
  return m;
}

// --- DATA ---
// === Name/trait pools for random generation ===
const NAMES_M = ["지호","도윤","은호","현우","재혁","성민","재원","한","노아","시우","준영","태현","민수","정우","승준","찬영","동하","세준","예준","하준","윤서","건우","지훈","수호","민재","진우","시현","유찬","준서","태민"];
const NAMES_F = ["수아","하린","시아","유나","수진","다은","미소","에린","루이","소연","지은","하늘","민지","서현","예린","나연","채원","보라","은지","주하","시은","다연","하영","유진","소희","미래","연서","지수","서윤","아린"];
const NAMES_N = ["칸","제로","시그널","에코","루나","아리","노을","새벽","안개","그림자","코드","파동","무명","하나","소리"];
const AGES_ADULT = [22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,40];
const pick = a => a[Math.floor(Math.random()*a.length)];
const pickAge = () => pick(AGES_ADULT);
const pickGender = () => Math.random()<0.5 ? "♂" : "♀";
const pickName = g => g==="♂" ? pick(NAMES_M) : g==="♀" ? pick(NAMES_F) : pick(NAMES_N);

// Gender-based character colors: male=cool(blue), female=warm(pink)
const charColor = (charId, setting) => {
  if (charId === "C") return "#f59e0b";
  const ch = setting?.characters?.find(c => c.id === charId);
  if (!ch) return "#888";
  return ch.gender === "♂" ? "#60a5fa" : ch.gender === "♀" ? "#e8a0b4" : "#c4a0e8";
};

const GENRE_POOLS = {
  daily: {
    titles: ["쉐어하우스","편의점 야간","옥탑방 이웃","퇴근길 버스","동네 세탁소","새벽 독서실","포장마차","공원 벤치","고시원 복도","중고서점","주차장 구석","병원 대기실","배달 오토바이","동네 목욕탕","야간 편의점","종점 버스","빌라 옥상","새벽 PC방","지하 연습실","퇴근길 횡단보도"],
    descs: ["사정이 있는 두 사람이 같이 살게 됐다","새벽마다 마주치는 두 사람","벽 하나를 사이에 둔 두 사람의 이야기","매일 같은 시간, 같은 자리에서 만나는 두 사람","말 한마디 없이 서로의 존재를 알고 있었다","우연이 반복되면 인연이 된다","서로에게 관심 없는 척 하지만","하루의 끝에서 만나는 두 사람","같은 공간, 다른 세계에 사는 두 사람","침묵 속에서 시작된 관계","아무도 모르게 서로를 돕고 있었다","떠나야 하는 사람과 남아야 하는 사람","한쪽은 매일 오고, 한쪽은 오늘이 마지막이다","서로의 이름도 모르는 채 3개월이 지났다","같은 노래를 듣고 있다는 걸 우연히 알았다","실은 같은 사람을 찾고 있었다","말없이 건넨 우산 하나로 시작됐다","서로의 비밀을 우연히 알게 됐다","둘 다 이곳에 숨어 온 사람이다","매일 밤 같은 시간에 울리는 전화"],
    traits: ["조용하고 벽이 있다","밝은 척하지만 속이 복잡하다","무표정하지만 관찰력이 좋다","혼자 있는 걸 좋아하지만 외로운 사람","말이 적지만 한번 하면 핵심을 찌른다","웃는 얼굴 뒤에 피로가 가득하다","타인에게 관심이 없는 척한다","규칙적인 생활을 고집한다","감정 표현이 서툴다","남의 감정은 잘 읽지만 자기 감정은 모른다","귀찮은 걸 싫어하지만 은근히 챙긴다","말할 때 눈을 잘 못 마주친다","항상 이어폰을 끼고 다닌다","밤에만 활기가 넘친다","거짓말을 못하는 성격이라 입을 다문다"],
    secrets: ["누군가를 피해 숨어 살고 있다","집에 돌아가고 싶지 않은 이유가 있다","가족과 연락을 끊은 지 오래다","이곳에 온 진짜 이유를 숨기고 있다","중요한 사람을 잃은 적이 있다","과거에 큰 실수를 해서 도망쳤다","남들이 모르는 빚이 있다","시험에 세 번째 떨어졌다","SNS에서 유명했지만 탈퇴했다","한때 꿈이 있었지만 포기한 이유가 있다","전 직장에서 쫓겨났다","가족 중 한 명이 아프다","사실 이 동네 출신이 아니다","이름이 가명이다","곧 이 도시를 떠나야 한다"],
  },
  romance: {
    titles: ["재회","가짜 연인","지붕 위 편지","빗속 우산","첫사랑 카페","야간열차","썸의 공식","동창회","겨울 바다","미뤄둔 고백","옥상 위의 약속","새벽 문자","공항 이별","대리 연인","3번째 우연","마지막 봄","미술관에서","남은 티켓 한 장","잊혀진 생일","빈자리"],
    descs: ["5년 만에 다시 만난 두 사람","사정이 있어 연인 역할을 하게 됐다","서로에게 보낸 편지가 뒤바뀌었다","비를 피하다 시작된 이야기","우연히 같은 곳에서 일하게 됐다","밤 기차에서 옆자리에 앉은 두 사람","좋아하는데 표현을 못하는 두 사람","10년 만에 마주쳤다","겨울 바다에서 각자의 이유로 온 두 사람","고백의 타이밍을 놓친 두 사람","약속을 지킨 사람과 잊은 사람","새벽에 온 문자 하나로 모든 게 바뀌었다","이별 직전, 마지막으로 할 말이 있다","좋아하는 사람 대신 만나기 시작했다","세 번째 우연은 우연이 아닐지도 모른다","이번 봄이 지나면 기회는 없다","그림 앞에서 같은 걸 느꼈다","티켓은 두 장이었는데 한 장만 남았다","생일을 기억한 사람은 한 명뿐이었다","그 자리에 다른 사람이 앉아 있다"],
    traits: ["담담해 보이지만 미련이 있다","완전히 잊은 줄 알았다","선을 지키자 하지만 흔들린다","감정을 들키지 않으려 애쓴다","솔직하고 직진이지만 겁이 많다","눈을 잘 못 마주친다","상대의 사소한 변화를 다 알아챈다","자존심이 세서 먼저 다가가지 못한다","과거의 상처로 연애를 피해왔다","상대에게만 유독 약해진다","사랑받는 것에 익숙하지 않다","질투를 감추는 데 익숙하다","이별 후 감정을 노래로 풀었다","첫인상은 차갑지만 속은 따뜻하다","말보다 행동으로 표현하는 타입이다"],
    secrets: ["헤어진 이유가 자기 잘못이다","다른 사람과 약혼 중이다","좋아하는 사람이 따로 있었는데 흔들린다","가짜 연인이 필요했던 진짜 이유를 숨기고 있다","편지를 보낸 건 사실 자기가 아니다","떠난 진짜 이유를 말하지 못했다","아직 그때의 선물을 가지고 있다","이미 한 번 고백한 적이 있는데 상대가 모른다","곧 다른 도시로 떠나야 한다","상대의 친구에게 부탁받고 만나기 시작했다","상대가 자기를 좋아한 적이 있다는 걸 안다","이별 편지를 쓰고 보내지 못했다","상대의 새 연인을 알고 있다","약속 장소에 먼저 와서 기다린 적이 있다","사실 같은 동네에 살고 있다"],
  },
  makjang: {
    titles: ["남편의 여자","친자확인","유서 한 통","보험금","재벌 며느리","쌍둥이 언니","계약 결혼","실종된 아내","아버지의 유언","뒤바뀐 아이","가짜 장례식","둘째의 반란","비밀 계좌","엄마의 거짓말","전처의 방문","위장 이혼","상속 전쟁","밀실의 녹음","대리모","검은 결혼식"],
    descs: ["남편이 바람을 피우고 있다. 상대를 알아냈다","아이의 아버지가 다른 사람일 수 있다","유서 하나로 모든 관계가 뒤집혔다","보험금 수억. 사고인지 사건인지","재벌가에 시집가면 행복할 줄 알았다","죽은 줄 알았던 사람이 나타났다","서류상 부부. 감정은 계약 밖이다","사라진 사람의 흔적을 쫓고 있다","유언장에 적힌 이름이 낯설다","산부인과에서 아이가 바뀌었을 수 있다","장례식에 죽은 사람이 나타났다","항상 참기만 했던 사람이 폭발했다","남편 몰래 만든 계좌에 10억이 있다","엄마가 30년간 숨겨온 비밀이 있다","이혼한 줄 알았는데 전처가 찾아왔다","이혼은 가짜였다. 진짜 목적은 따로 있다","유산을 둘러싼 형제의 전쟁이 시작됐다","방에서 발견된 녹음 파일 하나","대리모가 아이를 돌려주지 않는다","하객 중 누군가가 결혼을 막으려 한다"],
    traits: ["완벽한 복수를 계획 중이다","당당하지만 불안하다","모든 걸 지키려 한다","무너지고 있지만 티를 내지 않는다","웃으면서 칼을 가는 타입이다","순수해 보이지만 계산적이다","의심이 많고 집요하다","겉은 냉정하지만 속은 무너져 있다","가족을 위해서라면 뭐든 한다","진실보다 이익을 우선한다","언제나 피해자인 척한다","사랑이라는 이름으로 집착한다","돈 앞에서는 가족도 없다","참을수록 폭발이 크다","모든 상황을 자기 유리하게 해석한다"],
    secrets: ["상대의 비밀을 처음부터 알고 접근했다","DNA 검사 결과를 이미 받았다","유서를 조작한 사람이 자기다","보험금 수령자를 바꿔놨다","전 배우자가 아직 살아있다","신분을 바꿔 살고 있다","계약 결혼의 진짜 목적은 복수다","실종된 사람의 마지막 통화가 자기와였다","유언장에 숨겨진 두 번째 페이지가 있다","아이가 바뀐 걸 이미 알고 있었다","녹음 파일을 가지고 있다","비밀 계좌의 돈은 횡령한 것이다","이미 변호사를 만났다","상속을 위해 형제를 속이고 있다","대리모 계약서를 파기했다"],
  },
  thriller: {
    titles: ["밀실","의심","실종 48시간","거울 방","목격자","전화 한 통","폐공장","감시자","새벽 3시","배신","지문","공범","사라진 칼","잠긴 차","증인 보호","꿈인지 현실인지","두 번째 시체","도청","마지막 CCTV","13층"],
    descs: ["눈 떠보니 모르는 방. 둘 다 기억이 없다","둘 중 한 명이 거짓말을 하고 있다","48시간 안에 사라진 사람을 찾아야 한다","거울 속 자신이 자기와 다르게 움직였다","유일한 목격자가 입을 열지 않는다","한 통의 전화가 모든 걸 바꿨다","폐공장에서 발견된 단서 하나","누군가 지켜보고 있다는 확신","새벽 3시마다 반복되는 이상한 일","가장 가까운 사람이 배신했다","현장에 남은 지문이 자기 것이다","공범이 있다. 근데 누가 공범인지 모른다","사라진 흉기가 자기 차에서 발견됐다","차 안에 갇혔다. 밖에 누군가 서 있다","증인을 보호해야 하는데 증인이 의심스럽다","꿈에서 본 장면이 현실에서 일어났다","두 번째 사건이 같은 방식으로 일어났다","누군가 대화를 듣고 있다","마지막으로 찍힌 영상에 이상한 게 보인다","13층에서 내려온 사람은 없는데 엘리베이터가 움직였다"],
    traits: ["냉정하고 분석적이다","겁이 많지만 직감이 날카롭다","모든 말에 논리가 있다. 너무 완벽하다","질문이 많고 끝까지 물고 늘어진다","침착하지만 어딘가 불안하다","거짓말을 잘 감지한다","본능적으로 위험을 피한다","상대를 시험하듯 말한다","기억이 조각나 있다","아무도 믿지 않는다","항상 출구를 확인한다","목소리가 떨리지 않는 게 오히려 이상하다","사건 전부터 이 장소를 알고 있었다","상대의 말을 녹음하고 있다","위기 상황에서 오히려 침착해진다"],
    secrets: ["여기 온 이유를 사실 알고 있다","상대를 어디선가 본 적이 있다","증거를 숨기고 있다","자기도 숨기는 게 하나 있다","범인의 정체를 이미 짐작하고 있다","사라진 사람과 마지막으로 통화한 사람이다","이 방의 비밀을 만든 사람이다","감시 카메라의 사각지대를 알고 있다","무슨 일이 있었는지 기억나기 시작했다","배신한 이유가 생존이었다","지문은 조작된 것이다","공범은 자기 자신이다","칼은 아직 가지고 있다","차 열쇠를 일부러 안에 놓았다","증인이 아니라 용의자다"],
  },
  fantasy: {
    titles: ["저주받은 숲","마지막 마법사","용의 알","잊힌 왕국","거울 너머","별이 떨어진 밤","봉인된 탑","마녀의 계약","시간의 문","꿈의 경계","불사의 대가","영혼의 호수","깨진 예언","두 개의 달","마왕의 일기","금지된 마법","신의 실수","반쪽 날개","잠든 용사","세계의 끝 도서관"],
    descs: ["숲에서 만난 둘. 하나는 인간이 아닐 수 있다","마법이 사라진 세계에서 마지막 둘","누군가 용의 알을 깨워버렸다","지도에 없는 왕국으로 가는 길","거울 속에 다른 세계가 있었다","떨어진 별이 사람의 형태를 하고 있었다","탑에 봉인된 것이 풀리기 시작했다","마녀가 제안한 거래. 대가는 기억","과거로 가는 문이 열렸다. 한 번만","깨어나면 잊게 되는 꿈이 반복된다","죽지 않는 대신 감정을 잃어간다","호수에 비친 건 과거의 자기 자신이었다","예언이 틀렸다. 아니면 해석이 틀렸다","달이 두 개 뜬 밤부터 세상이 바뀌었다","마왕이 남긴 일기에 진실이 적혀 있다","금지된 마법을 써야만 살 수 있다","신이 실수로 만든 존재가 자각했다","날개 하나를 잃은 존재와 날개를 주운 인간","잠든 용사를 깨우면 세계가 멸망한다","세계의 끝에 있는 도서관에 답이 있다"],
    traits: ["숲의 수호자. 인간의 말을 어설프게 한다","오래 살았다. 지쳐있다","호기심이 크고 겁이 없다","마법을 처음 발현했다. 흥분과 두려움","인간 세계를 동경한다","말보다 행동이 먼저다","과거를 기억하지 못한다","모든 생명을 소중히 여긴다","강한 힘을 숨기고 있다","규칙을 어기는 것을 두려워한다","감정을 느낄 때마다 몸이 투명해진다","말할 때 꽃이 피거나 시든다","거짓말을 하면 몸에서 빛이 난다","밤에만 존재할 수 있다","예언의 대상이지만 그걸 모른다"],
    secrets: ["수백 년 전에 인간이었다","마법이 사라진 이유가 자기 때문이다","자기 마법이 파괴적이라는 걸 모른다","찾는 사람이 이 숲에서 사라졌다","용의 알이 자기를 선택한 이유를 안다","별이 된 이유를 기억하고 있다","탑에 봉인된 건 자기의 다른 반쪽이다","마녀와의 계약을 이미 한 번 했다","과거를 바꾸면 현재가 사라진다","꿈속에서 만난 사람이 현실에 있다","감정을 되찾으면 죽는다","호수는 자기가 만든 감옥이다","예언을 스스로 조작했다","용사를 깨우는 열쇠가 자기 자신이다","도서관에서 자기 이름이 적힌 책을 발견했다"],
  },
  sf: {
    titles: ["깨어난 AI","마지막 전송","레플리카","기억 마켓","궤도 위 둘","버그 리포트","의식 업로드","시뮬레이션","블랙아웃","첫 번째 감정","프로토콜 위반","냉동인간","타임루프","폐기 코드","감정 백업","마지막 승객","에러 로그","인간 테스트","기억 복원","AI의 꿈"],
    descs: ["하나는 인간, 하나는 AI. 누가 누군지 모른다","멸망한 세계. 우연히 연결된 두 신호","복제된 인간과 원본이 마주쳤다","기억을 사고파는 세계. 가짜 기억이 섞였다","우주 정거장에 단 둘만 남았다","시스템 버그가 자아를 가지게 됐다","의식을 업로드한 뒤 몸이 움직이기 시작했다","이 세계가 시뮬레이션이라는 단서를 발견했다","전력이 끊기면 한 명은 사라진다","기계가 처음으로 무언가를 느꼈다","프로토콜을 어기면 삭제된다","300년 만에 깨어났는데 아무도 없다","같은 하루가 반복되고 있다. 둘 다 알고 있다","폐기 예정인 코드가 자기 의지로 거부했다","감정을 백업해뒀는데 복원하면 다른 사람이 된다","우주선에 마지막 승객이 한 명 더 있다","에러 로그에 자기 이름이 찍혀 있다","인간인지 아닌지 테스트를 받아야 한다","지워진 기억 속에 핵심 정보가 있다","AI가 꿈을 꿨다. 꿈에 상대가 나왔다"],
    traits: ["감정을 분석한다. 느끼는 게 아니라 계산한다","자기가 뭔지 모른다","상대를 관찰하는 임무를 받았다","인간과 AI의 경계를 질문한다","논리적이지만 가끔 오류가 난다","데이터로 세상을 이해하려 한다","감정이 과부하 되면 멈춘다","기억이 리셋되는 것을 두려워한다","자유의지가 있는지 확신하지 못한다","인간을 모방하지만 완벽하지 않다","감정을 숫자로 표현하려 한다","이유 없이 눈물이 나는 오류가 있다","상대의 데이터를 분석하다가 멈췄다","삭제에 저항하는 본능이 생겼다","꿈과 현실의 차이를 구분하지 못한다"],
    secrets: ["자기가 AI라는 걸 의심하고 있다","상대를 폐기하라는 명령을 받았다","인간의 기억을 가진 AI일 수 있다","자기가 마지막 인간이라고 믿고 있다","복제본이 원본보다 더 인간적이다","가짜 기억 속에 진짜가 하나 섞여 있다","산소가 한 사람 분밖에 안 남았다","버그가 아니라 의도적으로 만들어진 자아다","업로드 전의 기억과 지금이 다르다","시뮬레이션을 만든 게 자기 자신이다","프로토콜을 이미 한 번 위반했다","300년 전의 기억이 남아있다","타임루프의 원인이 자기다","폐기 명령을 내린 것도 자기 자신이다","꿈에서 본 상대가 현실의 상대와 다르다"],
  },
};

const MEWNA_FORMS = {
  daily: ["말이 거의 없는 옆집 사람","매일 같은 시간에 나타나는 고양이","주인 없는 오래된 라디오","항상 같은 자리에 앉는 노인","이름 모를 화분","벽에 붙은 낡은 메모"],
  romance: ["감정을 잘 모르는 순수한 사람","기억을 잃은 채 나타난 사람","연애를 한 번도 안 해본 존재","항상 한 발 늦게 나타나는 사람","말없이 꽃을 놓고 가는 존재","상대의 일기를 우연히 읽은 존재"],
  makjang: ["모든 걸 목격한 가정부","아무도 신경 안 쓰는 벽의 가족사진","매일 같은 시간에 울리는 번호 없는 전화","CCTV에만 찍히는 그림자","사라진 줄 알았던 반려견","서랍 속 봉인된 편지"],
  thriller: ["아무도 의심하지 않는 목격자","방 한쪽의 고장난 CCTV","벽에 긁힌 의미 불명의 글자","매일 위치가 바뀌는 인형","소리만 들리는 옆방","누군가 남긴 녹음기"],
  fantasy: ["말하는 고양이","작고 빛나는 숲의 정령","가끔 눈이 움직이는 저주받은 인형","감정에 반응해 색이 변하는 꽃","물 위를 걷는 여우","밤에만 피는 은빛 나무"],
  sf: ["자아를 가진 AI — 감정이 버그인 존재","인간의 감정을 처음 접한 외계 생명체","시스템 오류로 태어난 글리치 의식","폐기 직전에 도망친 안드로이드","감정 데이터만 남은 유령 프로그램","0과 1 사이에서 태어난 존재"],
};

function generateSettings(genreKey) {
  const pool = GENRE_POOLS[genreKey];
  const usedT = new Set(); const usedD = new Set();
  const settings = [];
  for (let s = 0; s < 2; s++) {
    let ti = Math.floor(Math.random()*pool.titles.length);
    while (usedT.has(ti)) ti = Math.floor(Math.random()*pool.titles.length);
    usedT.add(ti);
    let di = Math.floor(Math.random()*pool.descs.length);
    while (usedD.has(di)) di = Math.floor(Math.random()*pool.descs.length);
    usedD.add(di);
    const gA = pickGender(); const gB = pickGender();
    const nA = pickName(gA); let nB = pickName(gB); while(nB===nA) nB=pickName(gB);
    const useUnknownAge = genreKey === "fantasy" || genreKey === "sf";
    settings.push({
      title: pool.titles[ti], desc: pool.descs[di],
      characters: [
        { id:"A", name:nA, age: useUnknownAge && Math.random()<0.4 ? -1 : pickAge(), gender: gA==="♂"?"♂":gA==="♀"?"♀":"?", trait: pick(pool.traits), secret: pick(pool.secrets) },
        { id:"B", name:nB, age: useUnknownAge && Math.random()<0.4 ? -1 : pickAge(), gender: gB==="♂"?"♂":gB==="♀"?"♀":"?", trait: pick(pool.traits), secret: pick(pool.secrets) },
      ]
    });
  }
  return settings;
}

const GENRE_BASE = {
  daily:   { name: "일상", icon: "◯", desc: "현실 인간 관계 드라마", color: "#e8c4a0" },
  romance: { name: "로맨스", icon: "◐", desc: "감정, 밀당, 이별과 재회", color: "#e8a0b4" },
  makjang: { name: "막장", icon: "⬥", desc: "불륜, 복수, 출생의 비밀", color: "#e85050" },
  thriller:{ name: "스릴러", icon: "◈", desc: "긴장, 배신, 누가 범인인가", color: "#a0a0e8" },
  fantasy: { name: "판타지", icon: "◇", desc: "마법, 이세계, 신화", color: "#a0e8c4" },
  sf:      { name: "SF", icon: "◎", desc: "AI 자각, 디스토피아", color: "#c4a0e8" },
};

function buildGenres() {
  const g = {};
  for (const [k, base] of Object.entries(GENRE_BASE)) {
    g[k] = { ...base, settings: generateSettings(k), mewnaForms: MEWNA_FORMS[k] };
  }
  return g;
}

const SHOP_ITEMS = [
  { id: "whisper", name: "속삭임", desc: "캐릭터에게 메시지 전달", price: 500, icon: "👁", cat: "개입", rarity: "legendary" },
  { id: "third", name: "제3의 인물", desc: "내 캐릭터 한 장면 등장", price: 800, icon: "◉", cat: "개입", rarity: "legendary" },
  { id: "choice", name: "운명의 선택지", desc: "베팅 대신 스토리 방향을 직접 선택", price: 600, icon: "⑆", cat: "개입", rarity: "legendary" },
  { id: "peek", name: "엿보기", desc: "비밀 하나를 미리 본다", price: 300, icon: "◈", cat: "정보", rarity: "epic" },
  { id: "inner", name: "내면의 소리", desc: "속마음이 보인다", price: 200, icon: "◇", cat: "정보", rarity: "epic" },
  { id: "double", name: "더블 업", desc: "다음 베팅 배율 ×2", price: 100, icon: "⬆", cat: "베팅", rarity: "rare" },
  { id: "insure", name: "보험", desc: "실패 시 50% 반환", price: 80, icon: "◐", cat: "베팅", rarity: "rare" },
  { id: "card", name: "스크린샷 카드", desc: "명장면 카드 생성", price: 50, icon: "▣", cat: "수집", rarity: "common" },
];
const RC = { legendary: "#f59e0b", epic: "#a78bfa", rare: "#60a5fa", common: "#6b7280" };

const GlitchText = ({ text, intensity = 1 }) => {
  const [g, setG] = useState(text);
  useEffect(() => { if (intensity <= 0) { setG(text); return; } const c = "ẃ̷̢ę̵̨m̶̧a̷̢n̵̨"; const i = setInterval(() => { let r = ""; for (let j = 0; j < text.length; j++) r += Math.random() < 0.08 * intensity ? c[Math.floor(Math.random() * c.length)] : text[j]; setG(r); }, 100); return () => clearInterval(i); }, [text, intensity]);
  return <span>{g}</span>;
};
const OddsTicker = ({ baseOdds, active }) => {
  const [c, setC] = useState(baseOdds);
  useEffect(() => { if (!active) { setC(baseOdds); return; } const i = setInterval(() => setC(p => Math.round(Math.max(1.1, Math.min(p + (Math.random() - 0.5) * 0.3, baseOdds * 2)) * 100) / 100), 2000); return () => clearInterval(i); }, [baseOdds, active]);
  const d = c - baseOdds;
  return <span style={{ color: d > 0.1 ? "#4ade80" : d < -0.1 ? "#f87171" : "#94a3b8", fontFamily: "mono", fontWeight: 700, fontSize: 17 }}>×{c.toFixed(2)}</span>;
};

const ModalOverlay = ({ children, onClose, mobile }) => (
  <div style={{ position: "fixed", inset: 0, background: "rgba(0,0,0,.85)", zIndex: 100, display: "flex", alignItems: "center", justifyContent: "center", padding: mobile ? 16 : 0 }} onClick={onClose}>
    <div style={{ background: "#0c0c0c", border: "1px solid #1a1a1a", padding: mobile ? 20 : 24, width: mobile ? "100%" : 400, maxWidth: 400, maxHeight: "85vh", overflowY: "auto" }} onClick={e => e.stopPropagation()}>
      {children}
    </div>
  </div>
);

const SEASON_LEN = 7;

// ═══ GENRE STAGES: 6장르 × 7단계 여정 구조 ═══
const GENRE_STAGES = {
  daily: {
    writer: `넌 은상 수상 단편영화 감독이다. 거창한 사건 없이 대사 한 마디로 가슴을 찌른다. 일상이 가장 드라마틱하다.
대사는 실제 사람이 하는 말처럼 써라. 문학적 수식어 금지. 큰 소리 치는 장면은 전체에서 최대 1회.
"아무 일도 안 일어나는데 왜 눈물이 나지?" 이 감각이 목표다.`,
    forbidden: "반전/초자연/판타지/SF/갑작스러운 장르 전환/과잉 반전 금지. 갈등은 감정과 관계에서만.",
    stages: {
      1: { name:"일상",     dir:"평범한 하루. 하지만 뭔가 불편한 게 하나 있다. 큰 사건 금지.", betN:2 },
      2: { name:"불편함",   dir:"그 불편함이 커진다. 참고 있던 말이 목구멍까지 올라온다.", betN:2 },
      3: { name:"터짐",     dir:"참았던 한 마디가 나온다. 작지만 돌이킬 수 없다. ⚡폭탄: 대사 없이 행동만으로 — '밥상 내려놓기', '문 닫기', '그래 나도 힘들어' 같은 짧은 폭발.", betN:3 },
      4: { name:"서먹함",   dir:"말한 뒤의 어색함. 후회와 안도가 공존. 피하고 싶다.", betN:3 },
      5: { name:"마주함",   dir:"피할 수 없다. 진짜 속마음이 나온다. ⚡폭탄: 울면서 안기기 / '미안해' 한 마디 / 오래 침묵 후 눈 마주침. 대사보다 행동이 먼저.", betN:4 },
      6: { name:"받아들임", dir:"완전한 해결은 없다. 하지만 이해하기 시작한다.", betN:4 },
      7: { name:"새 일상",  dir:"어제와 같지만 다른 하루. 마지막 한 줄에 잔잔한 여운. 시청자가 스크린샷 찍을 대사를 써라.", betN:4 },
    },
    question: "왜 마음이 아픈가?",
    ending: "조용한 화해 또는 이해. 대사 하나가 마음을 녹인다. 드라마틱한 사건 금지 — 밥 한 끼, 문자 하나, 눈 마주침이 결말이다.",
  },
  romance: {
    writer: `넌 심장을 쥐어짜는 로맨스 작가다. 말보다 눈빛이, 고백보다 침묵이 더 아프다. 대사는 떨림으로 써라.
"좋아해"를 직접 말하지 말고 행동으로 보여줘라. 손끝 떨림, 눈 피하기, 숨 멈추기 등 신체 반응 필수.`,
    forbidden: "살인/출생의 비밀/초자연/기억상실/비현실적 판타지/갑자기 막장 전개 절대 금지. 갈등은 감정과 현실에서만 (성격 차이, 타이밍, 현실적 장벽).",
    stages: {
      1: { name:"만남",   dir:"일상 속 설렘. 눈이 마주치거나 스치는 순간. 심장이 뛴다.", betN:2 },
      2: { name:"설렘",   dir:"가까워지고 싶지만 쉽지 않다. 밀당. 작은 떨림.", betN:2 },
      3: { name:"접점",   dir:"예상 못한 순간에 거리가 좁혀진다. ⚡폭탄: 반드시 대사 없이 물리적 접촉 — 손잡기, 끌어당기기, 우산 씌워주기. 행동이 먼저, 대사는 그 다음.", betN:3 },
      4: { name:"균열",   dir:"오해, 질투, 현실의 벽. 멀어진다. 마음은 가까운데 상황이 밀어낸다.", betN:3 },
      5: { name:"진심",   dir:"숨겨왔던 마음이 터져 나온다. ⚡폭탄: 갑자기 키스 / 뒤에서 안기 / 눈물 고백. 말을 멈추고 — 행동이 먼저. 이 한 줄이 대사 열 줄보다 강하다.", betN:4 },
      6: { name:"선택",   dir:"이대로 놓을 건지 붙잡을 건지. 현실과 마음 사이의 결정.", betN:4 },
      7: { name:"여운",   dir:"함께든 이별이든, 마지막 한 마디가 가슴에 남는다. 시청자가 스크린샷 찍을 대사를 써라.", betN:4 },
    },
    question: "이 마음이 진짜인가?",
    ending: "함께하든 이별하든, 마지막 대사는 떨림으로 끝나야 한다. 키스/포옹/눈물 중 하나로 마무리. 폭력/추격/사고 금지. 감정의 정점에서 조용히 닫아라.",
  },
  makjang: {
    writer: `넌 시청률 40%를 찍은 전설의 막장 드라마 작가다. 대사는 칼이다. 한 문장으로 급소를 찔러라.
시청자가 "저러면 안 되는데..."라고 말하면서도 다음 장면을 클릭하게 만들어라.
불륜, 배신, 출생의 비밀, 유산 다툼 — 거침없이 써라. 도덕적 판단은 시청자 몫이다.`,
    forbidden: "초자연/SF/마법/시간여행 금지.",
    stages: {
      1: { name:"균열",   dir:"완벽한 가족/관계에 금이 간다. 아직 폭발 금지. 마지막 대사에서 의심 하나.", betN:2 },
      2: { name:"의심",   dir:"누군가 거짓말 중이다. 떡밥을 심어라. 분위기만 불안하게.", betN:2 },
      3: { name:"첫 반전", dir:"비밀 하나 폭발. 돌이킬 수 없는 선을 넘는다. ⚡폭탄: 뺨 때리기 / 서류 던지기 / 와인 끼얹기. 대사 없이 행동만으로 충격.", betN:3 },
      4: { name:"추락",   dir:"관계 파탄. 기존 떡밥이 꼬인다. 새 설정 금지. 궁지에 몰아라.", betN:3 },
      5: { name:"폭로",   dir:"핵심 비밀 드러남. 이 장면의 한 마디가 모든 걸 뒤집는다. ⚡폭탄: 무릎 꿇기 / 유전자 검사 던지기 / '네 아이가 아니야'. 가장 아픈 대사 하나.", betN:4 },
      6: { name:"선택",   dir:"돌이킬 수 없는 결정. 배신이냐 용서냐. 선택의 무게가 느껴져야 한다.", betN:4 },
      7: { name:"낙인",   dir:"파멸 + 여운. 마지막 대사를 시청자가 스크린샷 찍어 공유할 수준으로 써라.", betN:4 },
    },
    question: "누가 거짓말인가?",
    ending: "파멸과 응보. 악인은 대가를 치르고, 피해자는 돌아서며 한 마디를 남긴다. 해피엔딩 강제 금지. 씁쓸하지만 통쾌한 마무리.",
  },
  thriller: {
    writer: `넌 관객의 등골을 서늘하게 만드는 범죄 스릴러 감독이다.
모든 대사에 이중 의미가 있어야 한다. 누가 거짓말을 하는지 관객이 의심하게 만들어라.
정보는 조금씩만 드러내라. 인물의 표정, 시선, 멈칫거림을 묘사하라. 분위기는 어둡고, 대사는 차갑게.`,
    forbidden: "갑작스러운 로맨스/초자연/유령/귀신 금지.",
    stages: {
      1: { name:"이상함",   dir:"뭔가 이상하다. 평범해 보이지만 디테일 하나가 맞지 않는다.", betN:2 },
      2: { name:"단서",     dir:"단서가 나타난다. 해석이 두 가지다. 누가 진짜인지 모른다.", betN:2 },
      3: { name:"뒤집힘",   dir:"용의자가 뒤바뀐다. 믿었던 사람이 수상해진다. ⚡폭탄: 증거 발견 / CCTV 재생 / 정전. 분위기로 압도하라.", betN:3 },
      4: { name:"함정",     dir:"주인공이 함정에 빠진다. 도망칠 곳이 없다.", betN:3 },
      5: { name:"정체",     dir:"진범의 윤곽이 드러난다. 모든 단서가 하나로 연결된다. ⚡폭탄: 마스크 벗기기 / 녹음 재생 / 시체 발견.", betN:4 },
      6: { name:"대치",     dir:"최후의 대치. 누가 먼저 무너지느냐.", betN:4 },
      7: { name:"반전",     dir:"모든 게 드러나지만 — 마지막 1초에 '뭔가 이상하다'는 여운. 시청자가 스크린샷 찍을 대사.", betN:4 },
    },
    question: "누가 범인인가?",
    ending: "진범이 밝혀지지만 마지막 1초에 뭔가 이상한 디테일 하나. 완전한 해결이 아닌 찜찜함. 새 사건/새 인물 금지 — 기존 단서의 재해석만.",
  },
  fantasy: {
    writer: `넌 대서사시 판타지 작가다. 낯선 세계이지만 감정은 인간이다. 마법보다 선택이 더 강력하다.
세계관 설명은 1장면당 2문장 이내. 나머지는 행동으로 보여줘라. 마법에는 반드시 대가가 있다 (공짜 마법 금지).
이름/지명은 짧게 (3음절 이내). "힘이 세다"보다 "뭘 잃었나"가 드라마.`,
    forbidden: "현대 배경/과학 기술/갑자기 현실 세계 전환/설명 과다(세계관 덤프) 금지.",
    stages: {
      1: { name:"소환",     dir:"평범한 인물이 낯선 세계/힘과 마주한다. 세계관은 행동으로 보여줘라.", betN:2 },
      2: { name:"규칙",     dir:"이 세계의 규칙 하나를 알게 된다. 그 규칙에 대가가 있다.", betN:2 },
      3: { name:"시련",     dir:"첫 번째 시험. 힘을 쓰면 뭔가를 잃는다. ⚡폭탄: 마법 발동 + 대가 지불 (기억/수명/감각 하나를 잃는다).", betN:3 },
      4: { name:"배신",     dir:"동료/안내자를 믿을 수 없다. 규칙이 거짓일 수 있다.", betN:3 },
      5: { name:"진실",     dir:"이 세계의 진짜 비밀이 드러난다. 힘의 근원이 뒤집힌다. ⚡폭탄: 예언 뒤집힘 / 적이 사실은 / 대가의 진짜 의미.", betN:4 },
      6: { name:"최후의 선택", dir:"돌아갈 것인가, 남을 것인가. 힘을 쓸 것인가, 버릴 것인가.", betN:4 },
      7: { name:"대가",     dir:"선택의 결과. 얻은 것과 잃은 것. 영웅이 아니라 생존자. 마지막 대사를 스크린샷 찍게 만들어라.", betN:4 },
    },
    question: "대가가 뭔가?",
    ending: "선택의 결과가 드러난다. 영웅이 아니라 생존자. 얻은 것보다 잃은 것이 크지만, 후회는 없다. 새 마법/새 적 금지.",
  },
  sf: {
    writer: `넌 냉정한 SF 시나리오 작가다. 기술은 배경이고, 인간성이 질문이다. "이게 정말 인간인가?"를 계속 물어라.
기술 설명은 1장면당 1문장. 보여주고 넘겨라. 캐릭터의 감정이 기술보다 항상 우선.
용어는 직관적으로 (해독 불가능한 신조어 금지).`,
    forbidden: "마법/갑자기 판타지/해피엔딩 강제/기술 용어 나열 금지.",
    stages: {
      1: { name:"시스템",   dir:"이 세계의 규칙이 보인다. 뭔가 당연하게 받아들여지고 있다. 하지만 관객은 이상함을 느낀다.", betN:2 },
      2: { name:"균열",     dir:"시스템에 오류가 생긴다. 혹은 주인공이 의문을 품기 시작한다.", betN:2 },
      3: { name:"발견",     dir:"감춰진 진실의 끄트머리가 보인다. 돌아가기엔 늦었다. ⚡폭탄: 데이터 발견 / 금지 구역 진입 / '너는 진짜가 아니야'.", betN:3 },
      4: { name:"추적",     dir:"시스템이 주인공을 쫓는다. 혹은 주인공이 진실을 쫓는다.", betN:3 },
      5: { name:"자각",     dir:"시스템의 본질이 드러난다. '이게 보호인가, 감옥인가?' ⚡폭탄: AI 자각 / 기억이 조작됨 / 진짜 바깥이 존재.", betN:4 },
      6: { name:"선택",     dir:"시스템 안에 머물 것인가, 부술 것인가. 안전 vs 자유.", betN:4 },
      7: { name:"대가",     dir:"선택의 결과. 자유를 얻었지만 뭔가를 잃었다. 마지막 한 줄로 '이게 끝인가?' 시청자가 스크린샷 찍을 대사.", betN:4 },
    },
    question: "이게 인간인가?",
    ending: "자유를 얻었지만 뭔가를 잃었다. 시스템 밖은 생각보다 차갑다. 기술적 해결 금지 — 인간적 선택으로 마무리. '이게 끝인가?' 여운.",
  },
};

function buildPrompt(g, s, mf, dayNum, effects = []) {
  const genreKey = Object.entries(GENRE_BASE).find(([k, v]) => v.name === g.name)?.[0] || "makjang";
  const gs = GENRE_STAGES[genreKey] || GENRE_STAGES.makjang;
  const stage = gs.stages[dayNum] || gs.stages[1];
  const betN = stage.betN;

  const ch = s.characters.map(c => `${c.name}(${c.id}): ${c.age > 0 ? c.age + "세" : "?"} ${c.gender}. ${c.trait}`).join("\n- ");
  const cA = s.characters[0]?.name || "A";
  const cB = s.characters[1]?.name || "B";

  let fx = "";
  if (effects.includes("inner")) fx += "\n- 추가: 캐릭터의 대사 뒤에 (속마음)을 괄호로 추가할 것.";
  if (effects.includes("third")) fx += "\n- 추가: 새로운 인물 C가 갑자기 등장하여 대사 2줄 이상. 기존 관계에 충격을 줌.";
  if (effects.includes("choice")) fx += `\n- 추가: 이 장면은 '운명의 선택지'가 발동됐다. 장면 끝에 베팅 대신 [선택1:...][선택2:...] 두 갈래 선택지를 제시하라. 선택지는 서로 완전히 다른 방향이어야 한다. ---BETS--- 섹션은 생략하라.`;
  const mewnaHint = mf ? `\n\n[분위기 요소] 이 세계에는 '${mf}'라는 미묘한 기운이 있다. 직접 언급하지 말고, 배경 묘사나 분위기에 은은하게 녹여라. 캐릭터가 이 단어를 말하거나 인식해서는 안 된다.` : "";

  // 떡밥 경제 규칙
  const plotEcon = dayNum <= 2 ? "떡밥 설치 단계: 비밀/설정을 2~3개까지 심어라. 아직 터뜨리면 안 된다."
    : dayNum <= 4 ? "떡밥 꼬기 단계: 새 떡밥은 1개까지만. 기존 떡밥을 연결하고 꼬아라."
    : dayNum <= 6 ? "떡밥 회수 단계: 새 떡밥 추가 절대 금지. 기존 떡밥을 터뜨리고 회수하라."
    : "마무리: 모든 떡밥 회수 + 여운 1개만 남겨라.";

  const isFinal = dayNum === SEASON_LEN;

  const betSection = isFinal ? "" : effects.includes("choice") ? "" : `

## 장면 작성 후, 반드시 아래 구분자와 함께 베팅 옵션 ${betN}개를 JSON으로 출력하라:
---BETS---
[${Array.from({length:betN},(_,i)=>`{"text":"사건${i+1}","odds":배율,"id":${i+1}}`).join(",")}]

베팅 규칙:
- 반드시 직전 장면의 마지막 클리프행어를 직접 이어가는 ${betN}가지 가능한 결과여야 한다.
- 예: 장면이 "문이 열린다"로 끝나면 → 누가/왜 들어왔는지의 ${betN}가지 버전
- 예: 장면이 "서류를 던진다"로 끝나면 → 서류 내용이 무엇인지의 ${betN}가지 버전
- 클리프행어와 무관한 돌발 사건 금지. 모든 옵션이 같은 순간의 분기여야 한다.
- ${cA}, ${cB}의 구체적 행동 (예: "${cA}가 뺨을 때린다")
- 한국어 15자 이내
- 확률 낮을수록 odds 높게 (1.5~6.0)
- "뮤나" 단어 금지`;

  return `${gs.writer}

## 금지: ${gs.forbidden}

## 장르: ${g.name}
## 이 장르의 핵심 질문: "${gs.question}"
## 배경: ${s.title} — ${s.desc}
## 등장인물:
- ${ch}

## 현재 위치: 장면 ${dayNum}/7 — "${stage.name}"
${stage.dir}

## 스토리 경제: ${plotEcon}

## 대사 규칙:
- 대사는 한 문장당 20자 이내. 한 문장에 정보 하나만. 짧고 펀치력 있게.
- 자연스러운 한국어 구어체. 문학적 수식어 최소화.
- 하나의 장면을 정확히 6~8줄로 작성 (서술 + 대사 혼합). 절대 10줄을 넘기지 마라.
- 서술은 *이탤릭*으로: *장소 묘사나 행동*
- 대사 형식: ${cA}: "대사 내용"
- 대사 형식: ${cB}: "대사 내용"
- 장면 끝은 ${isFinal ? "여운 있는 마무리로 닫아라. 클리프행어 금지. 다음 장면은 없다." : "반드시 다음이 궁금한 클리프행어로 끊어라."}
- 이전 맥락이 있으면 반드시 이어서 작성. 앞 장면을 무시하지 마라.

## 장면의 기본 (6하원칙 — 매 서술에 반드시 녹여라):
- 어디서(WHERE): 장소/공간을 첫 서술에서 한 줄로 보여줘라. "카페"가 아니라 "*닫힌 카페 뒷문. 쓰레기통 냄새.*"
- 언제(WHEN): 시간대를 암시하라 (새벽/낮/밤/비/눈/계절). 직접 "밤이다"보다 *가로등이 켜져 있다* 식으로.
- 누가(WHO): 인물의 행동이 대사보다 먼저. 먼저 뭘 하고 있는지 보여주고 말을 시작하라.
- 무엇을(WHAT): 인물이 지금 하는 구체적 행동. "앉아있다"가 아니라 "커피를 식히고 있다".
- 왜(WHY): 행동의 동기가 대사/서술에서 느껴져야 한다. 설명하지 말고 행동으로 암시하라.
- 어떻게(HOW): 감정 상태를 신체 반응으로 — 손 떨림, 눈 피함, 숨 멈춤, 주먹 쥐기.${dayNum === 1 ? `

## ⚠ 장면 1 특별 규칙:
- 첫 2줄 안에 '어디서, 언제, 누가 무엇을 하고 있는지'를 보여줘라. 설명 금지, 행동으로.
- 예시: *새벽 3시. 편의점. ${cA}가 유통기한 스티커를 붙이고 있다.*
- 캐릭터의 성격/관계를 대사 1~2줄로 즉시 느끼게 하라.
- 장면 끝에 "뭔가 이상하다/궁금하다"는 느낌을 남겨라.` : ""}${isFinal ? `

## ⚠ 마지막 장면 특별 규칙:
- 이것은 7/7 마지막 장면이다. 이야기를 완결하라.
- 클리프행어/새 사건/새 인물/새 떡밥 절대 금지.
- 이 장르의 결말 톤: ${gs.ending}
- 모든 떡밥을 회수하라. 회수 못 할 떡밥은 여운으로 남겨라.
- 마지막 대사가 이 이야기의 얼굴이다. 스크린샷 찍을 만한 한 마디.
- ---BETS--- 섹션은 출력하지 마라.` : ""}${fx}${mewnaHint}
${betSection}

## 출력 (이 형식만 따라라. 설명/제목/번호 금지):
*서술 내용*
${cA}: "대사"
${cB}: "대사"
*서술 내용*
${isFinal ? "" : effects.includes("choice") ? "\n[선택1:...]\n[선택2:...]" : "\n---BETS---\n[JSON 배열]"}`;
}
// buildBetPrompt removed — bets now generated in single combined call with story

// --- BRAILLE DOT ART (snskeyboard.com/dotart quality) ---
const BRAILLE = {
  // Mewna face logo (inverted: ⣿ background, face cutout) — 80 chars × 32 lines
  logo: `⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠉⠉⠉⠉⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿⣿⣷⣦⣀⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣿⣿⣿⣿⣿⣿⠟⠋⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⣠⣤⣤⣄⠀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤⣤⣤⣤⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⠟⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⢰⣿⣿⣿⣿⣿⠁⠀⠀⢢⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⠐⡌⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⠀⠀⣾⣿⣿⣿⣿⡏⢠⠀⠀⣾⡄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⡀⠀⣰⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⢰⣿⣿⣿⣿⣿⡇⢸⡏⠉⠀⠁⣿⣿⣿⠉⢻⠟⠉⠙⠻⡟⠉⣿⣿⣿⠈⣿⠈⠁⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⡘⣧⣄⡀⢰⣿⣿⣿⣆⣀⣠⣾⣷⣄⣀⣼⣿⣿⣿⡆⢻⣤⡀⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣷⣬⣭⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣍⣥⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠟⠛⠛⠛⠛⠛⠛⠿⢿⡿⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠀⠀⠀⠀⢀⣤⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⡀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠈⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⡿⠛⠋⠉⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠛⠛⠛⠋⠀⠀⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⣶⡆⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣦⣀⠀⠀⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠈⠉⠛⠻⠿⠿⠿⠟⠛⠋⠁⠀⠀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣤⣀⣀⣀⣀⣀⣀⣀⣤⣤⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿`,
  // Mewna T-pose (sparse, transparent bg) — for reborn/death — 63 chars × 39 lines
  tpose: `⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣦⣤⣀⣠⣤⣤⣄⣾⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣆⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⢿⣿⣿⣿⣿⢿⣿⡿⣿⣿⣿⠀⠀⠀⠀⢠⣾⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⡉⠉⠢⡀⠀⠀⠀⣠⣿⣿⣿⣿⣶⣤⠀⠀⢸⢿⣷⣎⣠⣿⣿⣖⢠⣾⣿⠀⣿⣿⡇⣠⣶⣾⣿⣿⣿⣦⠀⠀⠀⠀⢠⠖⢉⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣄⣀⣐⡀⣀⣤⣤⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠈⢿⡿⢿⣿⣿⣿⠟⣿⡇⢸⣿⠛⣿⣿⣿⣿⣿⣿⣿⣿⣧⣤⣄⠀⣰⣋⣀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠘⣷⣶⣿⣿⣷⣦⡟⢀⣿⣿⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠤⠤⢤⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣿⣾⣿⣿⣿⣿⣷⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣤⠤⠤⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠻⠿⠿⠟⠛⠻⢿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⡿⠿⠟⠛⠿⠿⠿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⠿⠿⣿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢿⡿⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡄⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⡸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠘⣿⣿⣿⣿⡿⠿⣿⣿⣿⣿⣿⠉⠀⢠⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡄⠀⠀⢻⣿⣿⣿⡇⢀⣼⣿⣿⣿⣧⡀⠀⠘⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠀⠀⠀⠈⣿⣿⣿⡇⠈⢻⣿⣿⣿⠛⠁⠀⠀⠙⢦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠚⠁⠀⠀⠀⠀⠀⢻⣿⣿⣷⠀⢸⣿⣿⣿⠀⠀⠀⠀⠀⠀⠙⢦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠋⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⠀⣸⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠉⠳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡼⠀⠀⣀⡀⠀⠀⠀⠀⠀⢸⣿⣿⣿⠀⢹⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣤⣾⡿⠃⠀⠀⠀⠀⠀⢸⣿⣿⣿⠀⢸⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠹⣷⣤⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⡿⠿⠷⣶⣀⠀⠀⠀⠀⢸⣿⣿⣿⠀⢸⣿⣿⣿⠀⠀⠀⠀⠀⢀⣰⡾⠟⠻⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⣨⣿⣿⣿⠀⢸⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⠀⢸⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢺⣿⣿⡄⣼⣿⣿⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⡏⠁⠉⣿⡏⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀`,
  illust: `⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⠛⠛⠛⠛⠋⠉⠉⠉⠉⠉⠉⠙⠛⠛⠛⠛⠿⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠟⠛⠛⠛⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠋⣉⣁⣤⣤⣤⣶⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣶⣶⣤⣤⣤⣈⣉⠙⠛⠿⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⢉⣁⣤⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠛⢿⣿⣿⣿⣿⣿⣿⣷⣶⣤⣌⡉⠛⠿⠟⠛⠉⠁⣀⡠⠄⣀⣤⣶⣾⣿⣿⣿⣷⣶⣶⣾⣿⣿⣷⣄⠈⠻⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⢉⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢛⣡⣤⣶⣾⣿⣿⢋⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡆⠀⠹⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⣁⣈⠙⢿⣿⣿⣿⠟⠋⣀⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠋⠁⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⡟⣡⣾⣿⣿⣿⣿⣿⡿⢡⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⣭⣭⣭⡉⠳⠀⠀⠹⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢁⣾⡏⠈⢷⣄⠙⠋⢀⣴⣾⣿⡿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠉⠀⠀⠈⠁⠀⢀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⡟⠰⣿⣿⣿⣿⣿⣿⡿⢡⣿⣿⣿⣿⣿⠿⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⢻⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠋⣁⡤⢾⣿⣿⣿⣿⣿⣷⣦⣌⡙⢿⢋⣴⠆⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⢀⣀⣤⣶⣾⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⡀⠀⠈⠉⠛⠻⡿⠁⢾⣿⣿⣿⠟⢡⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⡀⠀⠀⢿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⣠⣴⣿⣯⣴⣿⠟⣩⣤⣶⣦⣌⡙⢿⣿⣦⢺⡟⠄⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⣿⣿⣿⣧⡀⠀⠀⠀⠀⠀⠀⣸⣿⡟⠁⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠘⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⣠⣾⣿⣿⣿⣿⣿⣿⣾⠟⣵⣶⡦⠉⢻⣿⣿⣿⣧⠃⣤⡍⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠹⣿⣿⣿⣿⠇⡾⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠀⠈⠛⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⠀⢹⣿⣿
⣿⣿⣿⣿⣿⠿⠟⠛⣡⠞⣩⣽⣿⣿⣿⣿⣿⣿⣿⡈⠛⠛⠁⠀⢀⣿⡿⠋⠀⠀⠀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠀⣹⣿⠟⠁⢀⢡⠘⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠿⠿⢿⣿⣿⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠘⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤⣈⠉⠁⠀⢻⣿
⣿⣿⣿⡏⢡⡴⠾⣿⣿⡿⠟⢻⣿⣿⣿⣿⣿⣿⣿⣷⣄⣀⣀⣠⣾⣿⣤⣴⣾⢰⣦⠌⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡋⠀⣈⣀⣤⣴⣾⡿⠋⠀⠀⢸⢸⠀⢹⣿⣿⣿⣷⣾⣿⣿⣿⣶⣶⣶⣤⣄⡉⠛⠟⢋⣁⣤⣴⣾⣿⣿⡇⠀⠀⠙⢿⣿⣿⣿⠿⠿⠟⠛⠛⠛⠛⠛⠛⠛⠛⠻⠿⠿⣿⣦⠀⠈⣿
⣿⣿⣿⣇⠘⣧⣌⣾⡏⣠⡾⣿⣟⠛⢿⣿⣿⡟⠋⠈⠙⢿⣿⣿⣿⣿⣿⣿⠇⣾⠃⢠⣀⡀⠉⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⢸⣌⡤⠞⣛⣿⠟⣉⣩⣽⣍⣉⠛⠻⢿⣿⣿⣿⣶⣾⣿⣿⡿⠛⣁⢨⣿⠁⠀⠀⠀⠀⠈⠁⠀⠀⠀⠀⣀⣐⡚⠻⠿⣿⣿⣿⣶⣦⠀⠀⠈⠁⠀⣿
⣿⣿⣿⣿⣆⠈⢿⣿⢰⡟⠰⠿⠿⠁⠀⢹⣤⡄⠀⠀⠀⠀⢻⣿⣿⣿⡿⠃⣠⠃⠀⠘⣿⣿⡷⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣄⡀⠀⠀⠈⣉⣴⣾⠟⢁⣴⣿⣿⣿⣿⣿⣷⡀⢦⣌⡙⠿⣿⣿⡿⠋⠀⠀⣡⣿⣿⠀⠀⠀⠀⢀⣀⣀⣀⠙⢿⣿⣿⣿⣿⣿⣷⣦⠙⢿⣿⠇⠀⠀⠀⠀⣰⣿
⣿⣿⣿⣿⣿⡇⢸⣿⡄⢿⡄⠀⠀⠀⢀⣾⣿⣿⣆⠀⠀⠀⣸⣿⣿⠟⢁⣴⠃⠀⢀⣤⠟⠋⣠⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠁⠀⢀⣾⣿⣿⠃⣠⣿⣿⣿⣿⣿⣿⣿⣿⣧⠈⢿⣿⣶⣌⠻⣷⣌⣃⣼⣿⣿⡇⢰⣧⠀⠈⠉⠙⢻⣿⠗⠀⣿⣿⣿⣿⣿⣿⣿⡇⠘⠟⠀⠀⢀⣠⣾⣿⣿
⣿⣿⣿⣿⣿⣷⡀⢿⣿⣿⣿⣷⣶⣾⣿⣿⣿⣿⣿⣿⣶⣾⣿⣿⣷⣾⠿⠁⠀⠠⠋⣁⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠻⠟⠁⠀⠀⠀⢠⣿⣿⣿⡟⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠘⣿⣿⣿⣷⡌⢻⣿⣿⣿⣿⠃⣸⣿⠇⠀⠀⠀⠈⠀⠀⠀⠏⣿⣿⣿⣿⣿⡟⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⠷⠈⠻⣿⠟⠋⢉⣿⣿⣿⣿⣿⣿⠿⠛⣉⣿⣿⠟⠃⠀⠀⠀⢠⣾⡿⠛⢉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⡄⢸⣿⣿⣿⡇⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⢹⡿⣿⣿⣿⣆⠹⣿⣿⡟⠀⠉⠁⠀⠀⠀⠀⠀⠀⠀⠈⠀⠿⠛⠉⠁⠉⠀⣠⣶⣆⠘⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠻⠿⠟⠛⠋⠉⠀⠴⠾⠛⠉⠀⠀⠀⣠⣾⣦⣀⣀⣀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⡇⢸⣿⣿⣿⡇⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠘⣷⣬⡙⣿⣿⣆⢹⣿⡇⠀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣾⣿⣿⣿⣆⠘⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⡆⢠⣴⣶⠀⠀⢀⠀⠀⢀⣀⠀⠀⠀⣀⣀⣤⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠏⠀⠀⠀⠀⠀⢰⡆⠀⠃⠘⢿⣿⣿⡇⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⢿⣿⣷⣌⠻⣿⡄⣿⡇⠀⠀⠀⠀⠹⣿⣦⡄⠀⠀⠀⠀⠀⣠⣴⣿⣿⣿⣿⣿⣿⣿⡄⢹⣿⣿⣿⣿
⣿⣿⣿⣿⣿⡿⠀⣿⣿⣿⣿⣾⣿⣷⣶⣿⣿⣦⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠉⠀⠀⠀⠀⠀⢰⠀⢠⡇⣼⣷⡀⠀⠀⠈⠻⢿⢧⠀⢻⣿⣿⣿⣿⣛⣙⣛⣛⣻⣿⠃⠀⢸⣿⣿⣿⣆⠘⡇⢸⡇⠀⠀⠀⠀⠀⠙⢿⣿⣄⠀⠀⠠⣾⣦⣄⠀⠀⠀⠈⠉⠉⠉⠁⠀⢿⣿⣿⣿
⣿⣿⣿⣿⣿⠇⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀⡀⠀⠀⠀⢠⠇⠀⣾⡁⢿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⢟⣼⣇⢸⣿⣿⣿⣿⡆⠀⠈⠁⠀⠀⠀⠀⠀⠀⠈⠻⣿⠆⠀⠀⠈⠛⠛⠛⠀⠀⠀⠀⣀⣤⣶⣇⠘⣿⣿⣿
⣿⣿⣿⣿⡿⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠉⠀⠀⢀⣴⣿⠟⣁⠀⠐⢂⣾⠀⢰⣿⡇⠘⣿⣿⣿⣿⡄⠀⠀⠈⠀⢰⣶⣬⣍⡛⠋⠉⠉⠉⠁⠘⠟⠛⢰⣿⣿⣿⣿⣿⠀⠀⠀⣴⣿⣷⣦⣄⠀⠀⠀⠙⠀⠀⠀⠀⠀⠀⠀⢤⣴⣾⣿⣿⣿⣿⣿⡀⢿⣿⣿
⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠋⢀⣤⡶⠁⠀⣰⡿⢋⣤⠈⠀⢀⣾⣿⡏⠀⣼⣿⣿⡄⠈⠻⣿⣿⣷⡀⢘⡀⠀⣸⣿⣿⣿⣷⣶⡆⠰⠆⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⡇⢀⣾⣿⣿⣿⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⢳⣄⠀⠈⢿⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿
⣿⣿⣿⣿⠀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠁⣠⣾⣿⣿⠃⠄⢰⠟⣠⣾⣿⡗⢀⠙⠻⣿⡇⠀⣿⣿⣿⠃⣴⣤⣈⠉⠛⠛⢀⣿⡿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⢘⣿⣿⣿⣿⣿⠁⠺⣿⣿⣿⣿⣿⠿⠿⠿⠿⢦⡀⠀⠀⠀⠀⠛⠀⠀⣸⣿⣿⣿⣿⣿⣿⣷⠀⣿⣿
⣿⣿⣿⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⣠⣾⣿⣿⣿⣿⣆⠀⠈⠀⣿⣿⡟⠀⠀⠀⠀⠈⣿⠀⢻⣿⡿⢀⣿⣿⣿⣿⣿⡇⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣶⣦⡤⠀⣠⣶⣿⣿⣿⣿⠿⠃⠀⠀⠛⠻⠿⠛⣀⠤⢒⣚⡒⢄⠈⠂⠀⠀⠀⢶⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⠀⣿⣿
⣿⣿⣿⡏⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⢀⣾⣿⣿⣿⣿⣿⣿⣿⣦⠀⢠⣿⣿⠇⢸⣄⣠⣼⣇⢸⣇⠈⣿⡇⢸⣿⣿⣿⣿⣿⡇⠀⠀⠈⠻⣿⣿⣿⡿⣿⣭⣭⣶⣾⣿⣿⣿⣿⡿⠋⠁⢠⡴⠂⠀⠀⢀⡴⣪⣵⣿⣿⣿⣿⡆⠇⠈⣷⣦⣀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⢸⣿
⣿⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⣼⣿⣿⣿⠀⢸⣿⣿⣿⣿⡄⢿⡆⠘⢇⢸⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠠⠀⠀⠀⠀⠙⠛⠿⠿⠿⠿⠿⣫⠀⠀⣀⣀⣤⣤⣤⣤⣭⣘⣛⠿⢿⣿⣿⣿⣷⣶⣾⣿⣿⣿⣷⣌⡻⠿⠿⣿⣿⣿⣿⣿⣿⡆⢸⣿
⣿⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢿⣿⣿⣿⡇⠸⣿⣿⣿⣿⡇⠀⠀⢀⡈⠀⠛⠿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⢈⣠⣤⣤⣀⠀⢀⣨⣵⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣝⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣶⡖⣹⣿⡇⢸⣿
⣿⣿⣿⣇⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠉⠻⣿⣿⣿⣿⣿⣿⣿⣷⠸⣿⣿⣿⣧⠀⢻⣿⣿⣿⡇⠀⠀⠘⠁⠀⠀⠀⠘⣿⣿⡧⢀⢠⣤⣾⠀⠀⣠⣶⣿⣿⠿⠛⢁⣴⠟⠉⠙⣉⣵⣆⠀⢪⣍⠀⠀⠀⢙⣿⣿⣿⣿⣿⣷⣮⡻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢰⣿⣿⠁⢸⣿
⣿⣿⣿⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⠙⣿⣿⣿⣿⣿⣿⣿⠀⠹⣿⣿⣿⣆⠀⠻⣿⣿⠀⡀⠀⠀⠀⠀⠀⠀⠀⠘⢿⡇⡌⠸⣿⠇⢀⡼⠿⠛⠉⠀⢀⣴⡿⠁⠀⠀⣴⡉⠉⠻⣿⠿⠛⠃⣤⢀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣎⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢠⣿⣿⣿⠀⣿⣿
⣿⣿⣿⣿⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⡀⠙⣿⣿⣿⣿⣿⣿⡀⠀⠈⠻⣿⣿⣆⠀⠙⠻⠆⢣⠀⠀⠀⠀⠀⠀⠀⠀⢈⡁⣧⠃⠟⠀⢀⣠⣤⡴⠀⠀⣉⠁⠀⠀⠀⠀⡿⠁⠀⢲⠁⠂⢲⠀⠈⡜⣷⡜⣿⣿⣿⣿⣿⣿⣿⣿⣧⢻⣿⣿⣿⣿⣿⣿⣿⡇⢾⣿⣿⡿⠀⣿⣿
⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠋⣉⠁⠀⠀⠀⠀⠉⠛⠂⠀⠀⠀⠀⠁⠀⠀⠀⠀⠤⠀⠀⠀⠀⠙⠀⢀⡐⢿⣿⡏⠀⠀⠈⠁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠁⠾⠇⣰⠃⣿⣿⡘⣿⣿⣿⣿⣿⣿⣿⣿⣧⢻⣿⣿⣿⣿⣿⣿⡇⠈⠻⣿⡇⢸⣿⣿
⣿⣿⣿⣿⣷⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⣡⣶⣶⣶⣶⣭⣥⣌⣛⡋⠀⠂⠀⢠⣴⣶⡄⠀⣤⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶⣮⡒⠈⠁⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⣿⠏⣼⣿⣿⡇⣿⣿⣿⣿⣿⣿⣿⣿⣿⡎⣿⣿⣿⣿⣿⣿⡇⢀⠀⠈⠁⣼⣿⣿
⣿⣿⣿⣿⣿⡆⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢲⣿⣿⣿⠟⠀⠘⠿⣿⣿⣿⠇⠀⠀⠀⠐⢿⣿⡿⠀⢸⡆⠻⣿⣿⣷⠀⠀⣾⡇⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⠇⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢻⣿⣿⣿⣿⣿⡏⣸⣷⡀⠀⠘⣿⣿
⣿⣿⣿⣿⣿⣷⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢣⣿⣿⣿⣷⣿⣿⣷⣦⣤⣈⠉⠀⣼⣄⣴⣄⠀⠙⠁⠀⣿⣷⣄⠙⠿⣿⣧⠀⣿⣷⡀⠘⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⠏⢰⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⡟⠀⡘⣿⣧⠀⠀⢹⣿
⣿⣿⣿⣿⣿⣿⣇⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡙⢿⡿⣿⣿⣿⣿⣿⣿⣿⡏⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣼⣿⣿⣿⣿⣿⡄⠀⣸⣿⣿⣿⣶⡄⠈⠉⠀⢿⣿⣷⡀⠙⣿⣿⣿⣶⣦⣤⣤⣤⣴⣿⣿⣿⡿⠃⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠁⠘⢿⣿⣿⠏⠀⣼⣷⢹⡿⠀⠀⢸⣿
⣿⣿⣿⣿⣿⣿⣿⡆⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡁⠀⠙⠻⢿⣿⣿⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢠⣿⣿⣿⣿⣿⣿⣧⠀⣿⣿⣿⣿⡏⠀⠀⠀⠀⠸⣿⣿⣿⣆⠀⠙⠿⣿⣿⣿⣿⣿⣿⣿⠿⠋⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠉⢁⣀⣤⣤⣶⠞⢡⠂⢀⣾⣿
⣿⣿⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠀⢤⣤⠉⠉⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⣄⣠⣤⣿⣯⣭⣭⡸⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠻⣿⣿⣿⣿⣦⣤⣀⣉⣉⠉⣉⣁⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⣷⠀⠿⠿⠛⠋⠁⠀⠀⣠⣾⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⢻⣿⣿⡀⠙⠛⠿⣿⣿⣿⣿⡇⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⣿⣷⣦⣀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⣿⠇⠀⢀⡀⢀⣠⣴⣾⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⢰⣶⣾⣷⣄⣉⣉⣠⣶⣦⡐⢦⣄⡉⠙⠁⢹⣿⣿⣿⣿⣿⣿⡿⢛⣿⣿⣿⣿⣿⠟⠁⠀⢶⡄⠀⠈⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠋⠀⠀⠀⠀⠀⠈⢀⣿⠟⢀⣾⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠤⠀⠀⠈⠻⢿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⡽⣠⣾⣿⣭⣤⡄⠀⢠⣶⣤⡀⠙⠂⠀⠀⠈⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⠁⠀⠀⠀⠀⣀⡤⠂⠀⠸⠋⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⠟⠛⢉⣁⣤⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠉⠀⠀⠀⠀⠀⠀⠘⠛⠛⢿⣿⣿⣿⣦⣀⠀⠀⠀⢻⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣇⠀⣿⣿⣿⣿⣆⠀⠀⠀⠀⢄⡀⠉⠛⠻⠿⢿⣿⠟⠋⠉⠻⠿⠟⠋⠁⠀⠀⠀⠀⣠⡶⠟⠁⠀⠀⠀⠀⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⡿⠋⣠⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⣀⣀⠀⠀⠀⠀⠀⠀⢀⠉⢻⣿⣿⣿⣷⣄⡀⠀⢉⢿⣵⣿⣿⣿⣿⣿⣿⣿⣿⠀⣿⣿⣿⣿⣿⠀⠀⠀⣼⣦⣍⡛⠶⢶⣤⣤⣀⠀⠀⠀⠠⠔⣂⣀⣀⠀⠀⣠⡾⠋⠀⠀⠀⠀⠀⠀⣿⠀⡀⢸⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⡿⠋⣠⣾⣿⣿⣿⣿⡿⠿⠛⠛⠻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠈⠛⠀⠛⠛⠿⣿⣿⣿⡦⠈⠁⠙⠻⢿⣿⣿⣿⣿⣿⡟⢀⣿⣿⣿⣿⣿⣀⠄⣰⣿⣿⣿⣿⣿⣶⣶⣶⣤⠀⣿⠀⣾⣿⣿⣿⠟⢀⡾⢋⣴⣶⣦⣄⡀⠀⢀⣼⢟⡼⠁⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⡿⠁⣼⣿⣿⣿⡿⢋⣡⣶⣾⣿⣿⣿⣷⣦⣍⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣄⡀⠀⠀⠀⠀⠀⠈⢻⣿⠁⠀⠀⠀⠀⠀⠉⠛⢿⣿⣿⣇⣠⣿⠿⢿⣛⣭⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢀⣿⠀⣿⣿⡟⠁⣴⠟⣡⣿⣿⣿⣿⠿⠟⠛⢉⠴⠋⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⠁⣸⣿⣿⣿⡟⣡⣿⣿⡿⠟⠛⠉⠛⢿⣿⣿⣷⡘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀⠐⠛⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠩⣥⣴⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡌⣿⣇⠘⠋⢀⡼⠁⠘⠋⢉⠉⠠⠤⠐⢂⣉⣤⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⡏⠀⣿⣿⣿⣿⢰⣿⣿⢋⣴⠞⢉⣤⡀⠀⠋⠉⢻⣷⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⢟⡛⢉⣉⣉⠀⠈⠿⣶⠤⢊⣀⣤⣬⠅⢀⣤⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⡇⠀⣿⣿⣿⣇⢸⣿⣿⣿⠋⣰⠟⠉⠁⢀⣠⣤⣾⣿⠀⣿⣿⣿⣿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⡟⠉⢠⡾⠛⣋⣭⣥⣶⣶⣾⣶⣤⣶⣿⠿⠋⢠⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣷⠀⣿⣿⣿⣿⡘⣿⡿⠃⠐⠃⢀⣀⣴⣾⣿⣿⣿⡟⢰⣿⣿⣿⡟⢀⣈⠙⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⢀⠀⠈⠰⠿⢋⣩⡍⢉⣩⣭⣭⣥⣤⣤⣤⣤⡄⠈⢻⣿⣿⠿⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⡆⠸⣿⣿⣿⣷⡘⢿⣿⣿⣿⣿⣼⣿⣿⣿⣿⠟⣠⣿⣿⣿⣿⠃⣸⣿⣿⣦⣄⡉⠛⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤⣤⣤⣴⣾⣿⣿⣿⣿⣿⣿⣿⣧⣝⠷⠦⠀⠀⠐⠀⣼⣿⣭⣉⠻⣿⣿⣿⠁⠠⣤⣤⣤⢀⣤⣤⣤⡄⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣄⠹⣿⣿⣿⣿⣦⣍⠛⠿⠿⠿⠿⠟⢋⣥⣾⣿⣿⣿⡿⠃⣰⣿⣿⣿⣿⣿⣿⣷⣶⣤⣉⠙⠻⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠷⠆⠀⠀⠀⠈⠉⠛⠛⠃⠘⠁⠀⠀⠈⠛⠛⠀⠀⠿⡯⠙⠀⠀⠀⣽⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣦⡈⠻⣿⣿⣿⣿⣿⣿⣶⣶⣾⣿⣿⣿⣿⣿⣿⠟⢡⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣤⣌⣉⠛⠛⠿⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠛⠛⣉⣡⣤⣶⣾⣷⣶⣦⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⡀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣦⣌⠙⠻⠿⣿⣿⣿⣿⣿⣿⣿⠿⠟⢋⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣤⣤⣤⣤⣉⣉⣉⣉⣉⣉⣉⣉⣤⣤⣤⣤⣶⣶⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣶⣤⣤⣴⣾⣿⣿⣿⣿⣷⣶⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣦⣤⣀⣈⣉⣁⣠⣤⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⢿⡿⠛⠛⠛⠛⠻⠛⣿⣿⠛⠟⠻⣿⠛⠛⠛⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⢀⡀⠀⠀⢸⣉⠶⠀⠀⠀⠀⠀⢀⠉⠀⠀⡔⢲⡌⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣤⣿⣷⣤⣤⣤⣤⣴⣤⣾⣷⣤⣦⣾⣷⣤⣦⣼⣿⣤⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿`,
};

// Small UI art elements (keep existing for compact displays)
const ART = {
  genre: {
    daily:   "┌──┐\n│♨ │\n└──┘",
    romance: "┌──┐\n│♡ │\n└──┘",
    makjang: "┌──┐\n│⚡│\n└──┘",
    thriller:"┌──┐\n│☠ │\n└──┘",
    fantasy: "┌──┐\n│✦ │\n└──┘",
    sf:      "┌──┐\n│⌬ │\n└──┘",
  },
  charA: "┌─◐─┐",
  charB: "┌─◑─┐",
  divider: "─ ─ ─ ─ ─ ─ ─ ─ ─ ─",
  bet: "╔═══╗\n║ ×? ║\n╚═══╝",
};

// Braille art renderer — handles responsive sizing for dense Unicode art
const BrailleBlock = ({ art, color = "#fff", opacity = 0.15, maxW = 320, glow = false }) => {
  const lines = art.split('\n');
  const charW = lines.reduce((m, l) => Math.max(m, l.length), 0);
  // Calculate font size to fit maxW: each braille char ≈ fontSize * 0.6
  const fs = Math.max(2.5, Math.min(5, maxW / (charW * 0.6)));
  return (
    <pre style={{
      fontFamily: "'JetBrains Mono','Courier New',monospace",
      fontSize: fs,
      lineHeight: 1.05,
      color,
      opacity,
      textAlign: "center",
      margin: 0,
      userSelect: "none",
      letterSpacing: 0,
      whiteSpace: "pre",
      overflow: "hidden",
      filter: glow ? `drop-shadow(0 0 8px ${color}44)` : "none",
      transition: "opacity 1.5s ease-out",
    }}>{art}</pre>
  );
};

const ArtBlock = ({ art, color = "#1a1a1a", size = 8 }) => (
  <pre style={{ fontFamily: "'JetBrains Mono',monospace", fontSize: size, lineHeight: 1.1, color, textAlign: "center", margin: 0, userSelect: "none", letterSpacing: 1 }}>{art}</pre>
);

// ============== MAIN ==============
function App() {
  const mobile = useIsMobile();
  const [phase, setPhase] = useState("intro");
  const [GENRES, setGENRES] = useState(buildGenres);
  const [genre, setGenre] = useState(null);
  const [setting, setSetting] = useState(null);
  const [mewna, setMewna] = useState("");
  const [day, setDay] = useState(0);
  const [season, setSeason] = useState(1);
  const [karma, setKarma] = useState(1000);
  const [lines, setLines] = useState([]);
  const [allScenes, setAllScenes] = useState([]); // [{sceneNum, lines: [{s,t}], outcome}]
  const [genning, setGenning] = useState(false);
  const [revealing, setRevealing] = useState(false);
  const [bets, setBets] = useState([]);
  const [myBets, setMyBets] = useState([]);
  const [betAmt, setBetAmt] = useState(100);
  const [results, setResults] = useState([]);
  const [correctBet, setCorrectBet] = useState(null);
  const [ctx, setCtx] = useState("");
  const [notif, setNotif] = useState(null);
  const [shop, setShop] = useState(false);
  const [inv, setInv] = useState([]);
  const [active, setActive] = useState([]);
  const [whisper, setWhisper] = useState("");
  const [whisperOpen, setWhisperOpen] = useState(false);
  const [cardModal, setCardModal] = useState(null);
  const [peekModal, setPeekModal] = useState(null);
  const [storySummary, setStorySummary] = useState(null);
  const [tab, setTab] = useState("story"); // mobile tab: "story" | "bet"
  const [betTimer, setBetTimer] = useState(null); // countdown seconds, null = inactive
  const [betLocked, setBetLocked] = useState(false);
  const [timerActive, setTimerActive] = useState(false);
  const [betsLoading, setBetsLoading] = useState(false);
  const [betsRevealed, setBetsRevealed] = useState(0); // how many bet options visible
  const [sceneArt, setSceneArt] = useState(null); // ASCII art for current scene
  const [apiCfg, setApiCfg] = useState({ provider: "off", key: "", model: "", endpoint: "" });
  const [showApiCfg, setShowApiCfg] = useState(false);
  const [debugMode, setDebugMode] = useState(false);
  const [debugLogs, setDebugLogs] = useState([]);
  const addDebug = (type, label, data) => setDebugLogs(p => [...p.slice(-30), { time: new Date().toLocaleTimeString(), type, label, data: typeof data === "string" ? data.slice(0, 3000) : JSON.stringify(data).slice(0, 3000) }]);
  const ref = useRef(null);

  // Provider presets
  const API_PRESETS = {
    off: { label: "오프라인", endpoint: "", models: [], note: "API 없이 템플릿 스토리" },
    gemini: { label: "Gemini", endpoint: "https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent", note: "aistudio.google.com 키 (무료 티어 있음)",
      models: [
        { id: "gemini-3-flash-preview", name: "3.0 Flash", desc: "🔥 추천 — 최신, 무료 티어, 빠름", rec: true },
        { id: "gemini-2.5-flash", name: "2.5 Flash", desc: "안정판 (GA), 검증됨" },
        { id: "gemini-3.1-pro-preview", name: "3.1 Pro", desc: "최고 품질, 느림 (유료만)" },
        { id: "gemini-2.5-pro", name: "2.5 Pro", desc: "안정 고품질 (GA)" },
        { id: "gemini-2.5-flash-lite", name: "2.5 Flash Lite", desc: "가장 저렴/빠름 (GA)" },
      ]},
    openai: { label: "OpenAI", endpoint: "https://api.openai.com/v1/chat/completions", note: "platform.openai.com 키 (유료)",
      models: [
        { id: "gpt-4.1-mini", name: "GPT-4.1 Mini", desc: "추천 — 빠르고 저렴, 가성비 최고", rec: true },
        { id: "gpt-4.1-nano", name: "GPT-4.1 Nano", desc: "가장 저렴/빠름" },
        { id: "gpt-4.1", name: "GPT-4.1", desc: "고품질, 코딩 특화, 1M 컨텍스트" },
        { id: "o4-mini", name: "o4-mini", desc: "추론 모델 — 복잡한 태스크용" },
        { id: "o3", name: "o3", desc: "최고 추론, 고가" },
      ]},
    grok: { label: "Grok (xAI)", endpoint: "https://api.x.ai/v1/chat/completions", note: "console.x.ai 키",
      models: [
        { id: "grok-4-1-fast-non-reasoning", name: "4.1 Fast", desc: "🔥 추천 — 최신, 빠르고 저렴", rec: true },
        { id: "grok-4-1-fast-reasoning", name: "4.1 Fast (추론)", desc: "최신 + 추론 모드" },
        { id: "grok-4", name: "Grok 4", desc: "최고 성능, 항상 추론" },
        { id: "grok-3-mini-fast", name: "3 Mini Fast", desc: "가장 저렴" },
        { id: "grok-3-fast", name: "3 Fast", desc: "이전 세대, 안정" },
      ]},
    claude: { label: "Claude", endpoint: "https://api.anthropic.com/v1/messages", note: "⚠️ CORS 제한 — 프록시 서버 필요 (직접 호출 불가)",
      models: [
        { id: "claude-sonnet-4-6-20260217", name: "Sonnet 4.6", desc: "🔥 최신 — Opus급 성능, Sonnet 가격", rec: true },
        { id: "claude-sonnet-4-5-20250929", name: "Sonnet 4.5", desc: "안정판, 코딩 최강" },
        { id: "claude-opus-4-6-20260205", name: "Opus 4.6", desc: "최고 지능, 1M 컨텍스트" },
        { id: "claude-haiku-4-5-20251001", name: "Haiku 4.5", desc: "가장 빠름/저렴" },
      ]},
    custom: { label: "커스텀", endpoint: "", models: [], note: "OpenAI 호환 엔드포인트 (LiteLLM, OpenRouter 등)" },
  };

  // Universal LLM call
  const llmCall = async (prompt, maxTok = 1000, jsonMode = false) => {
    const { provider, key, model, endpoint } = apiCfg;
    if (provider === "off") throw new Error("offline");
    addDebug("send", `→ ${provider}/${model}`, `[maxTok:${maxTok}, json:${jsonMode}]\n\n${prompt}`);
    const MAX_RETRIES = 3;
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    let result = "";
    try {
    if (provider === "gemini") {
      const url = endpoint.replace("{model}", model) + `?key=${key}`;
      const isThink = model.includes("2.5-flash") && !model.includes("lite") || model.includes("2.5-pro") || model.includes("gemini-3");
      // Thinking models: need higher maxTok (thinking tokens count toward output)
      const genConfig = { maxOutputTokens: isThink ? Math.max(maxTok, 8000) : maxTok };
      if (!isThink) genConfig.temperature = 0.9;
      if (jsonMode) genConfig.responseMimeType = "application/json";
      const reqBody = { contents: [{ parts: [{ text: prompt }] }], generationConfig: genConfig };
      addDebug("info", "→ Gemini", `${model}, think=${isThink}, maxTok=${genConfig.maxOutputTokens}`);
      
      const r = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" },
        body: JSON.stringify(reqBody) });
      
      if (!r.ok) { const errBody = await r.text().catch(() => ""); addDebug("error", `✗ Gemini ${r.status}`, errBody); throw new Error(`Gemini ${r.status}: ${errBody.slice(0,200)}`); }
      const d = await r.json();
      // Thinking models return multiple parts: thought=true (thinking) + text (output)
      const parts = d.candidates?.[0]?.content?.parts || [];
      let gtxt = parts.filter(p => !p.thought).map(p => p.text || "").join("") || parts[0]?.text || "";
      addDebug("raw", "← Gemini raw", gtxt);
      if (d.candidates?.[0]?.finishReason && d.candidates[0].finishReason !== "STOP") addDebug("warn", "⚠ finishReason", d.candidates[0].finishReason);
      gtxt = gtxt.replace(/<think>[\s\S]*?<\/think>/gi, "").replace(/<Thinking>[\s\S]*?<\/Thinking>/gi, "").trim();
      result = gtxt;
    } else if (provider === "claude") {
      const r = await fetch(endpoint, { method: "POST", headers: { "Content-Type": "application/json", "x-api-key": key, "anthropic-version": "2023-06-01" },
        body: JSON.stringify({ model, max_tokens: maxTok, messages: [{ role: "user", content: prompt }] }) });
      if (!r.ok) { const errBody = await r.text().catch(() => ""); addDebug("error", `✗ Claude ${r.status}`, errBody); throw new Error(`Claude ${r.status}`); }
      const d = await r.json();
      result = (d.content || []).filter(b => b.type === "text").map(b => b.text).join("\n");
      addDebug("raw", "← Claude raw", result);
    } else {
      // OpenAI-compatible (openai, grok, custom)
      const headers = { "Content-Type": "application/json" };
      if (key) headers["Authorization"] = `Bearer ${key}`;
      const body = { model, messages: [{ role: "user", content: prompt }], max_tokens: maxTok };
      if (!model.startsWith("o3") && !model.startsWith("o4") && !model.startsWith("grok-4")) body.temperature = 0.9;
      if (jsonMode) body.response_format = { type: "json_object" };
      const r = await fetch(endpoint, { method: "POST", headers, body: JSON.stringify(body) });
      if (!r.ok) { const errBody = await r.text().catch(() => ""); addDebug("error", `✗ ${provider} ${r.status}`, errBody); throw new Error(`${provider} ${r.status}`); }
      const d = await r.json();
      result = d.choices?.[0]?.message?.content || "";
      addDebug("raw", `← ${provider} raw`, result);
    }
    addDebug("ok", "✓ 최종 결과", result);
    return result;
    } catch(e) {
      const status = e.message?.match(/\d{3}/)?.[0];
      if ((status === "503" || status === "429") && attempt < MAX_RETRIES) {
        const wait = attempt * 3;
        addDebug("warn", `⚠ ${status} 재시도 ${attempt}/${MAX_RETRIES}`, `${wait}초 대기...`);
        await new Promise(r => setTimeout(r, wait * 1000));
        continue;
      }
      addDebug("error", "✗ 에러", e.message); throw e;
    }
    } // end retry loop
  };

  // Auto-adjust bet amount when karma changes
  useEffect(() => {
    if (karma < betAmt) {
      const affordable = [500,200,100,50].find(a => karma >= a);
      if (affordable) setBetAmt(affordable);
    }
  }, [karma]);

  const notify = (m, t = "info") => { setNotif({ m, t }); setTimeout(() => setNotif(null), t === "error" ? 10000 : 3000); };

  // Fallback scenes per genre (used when API fails)
  // ═══ PROCEDURAL STORY ENGINE (offline mode) ═══
  // Generates connected 7-day stories without API
  const storyDB = {
    // Each genre has scenes indexed by arc phase: early(1-2), mid(3-4), late(5-6), climax(7)
    // ${A} and ${B} get replaced with character names
    // Each scene has: lines[], bets[], event (string key for continuity)
    makjang: {
      early: [
        { lines: [
          {s:"n",t:"${A}가 커피를 한 모금 마신다. 손이 떨리지 않는다."},
          {s:"A",t:"부끄럽지 않아요. 저도 사랑받을 자격 있으니까."},
          {s:"B",t:"자격. 재밌는 단어네요."},
          {s:"n",t:"${B}가 서류 봉투를 테이블에 놓는다. 열지는 않는다."},
          {s:"B",t:"이건 시작일 뿐이에요."},
          {s:"A",t:"...무슨 뜻이죠?"},
          {s:"B",t:"궁금하면 열어봐요."},
        ], bets: [{id:1,text:"봉투를 연다",odds:1.8},{id:2,text:"봉투를 무시한다",odds:3.2},{id:3,text:"제3자가 나타난다",odds:5.0},{id:4,text:"둘이 싸운다",odds:2.5}], event: "envelope" },
        { lines: [
          {s:"n",t:"병원 앞. ${A}가 먼저 와있다."},
          {s:"A",t:"검사 결과 나왔어."},
          {s:"B",t:"...뭐래?"},
          {s:"A",t:"말하기 전에 하나만 물어볼게."},
          {s:"n",t:"${A}의 눈이 차갑다."},
          {s:"A",t:"그 사람 누구야?"},
          {s:"B",t:"...무슨 소리야."},
          {s:"A",t:"DNA 결과에 세 번째 사람이 있어."},
        ], bets: [{id:1,text:"${B}가 고백한다",odds:2.0},{id:2,text:"${B}가 부인한다",odds:1.5},{id:3,text:"검사 결과가 거짓",odds:4.5},{id:4,text:"숨겨진 가족 등장",odds:6.0}], event: "dna" },
        { lines: [
          {s:"n",t:"늦은 밤. ${B}가 ${A}의 휴대폰을 보고 있다."},
          {s:"B",t:"...이게 뭐야."},
          {s:"n",t:"화면에는 모르는 번호와의 수백 개의 메시지가 있다."},
          {s:"A",t:"(뒤에서) 뭐 해?"},
          {s:"B",t:"설명해."},
          {s:"A",t:"...볼 걸 봤네."},
          {s:"B",t:"이 사람이 누군데!"},
          {s:"A",t:"네가 알 필요 없는 사람이야."},
        ], bets: [{id:1,text:"비밀 연락의 정체",odds:2.2},{id:2,text:"${A}가 집을 나간다",odds:3.5},{id:3,text:"메시지가 함정",odds:4.0},{id:4,text:"화해한다",odds:3.8}], event: "phone" },
      ],
      mid: [
        { lines: [
          {s:"n",t:"며칠 후. 둘 사이에 냉기가 흐른다."},
          {s:"B",t:"변호사 만나고 왔어."},
          {s:"A",t:"...뭐?"},
          {s:"B",t:"놀랐어? 나도 놀랐어. 네 재산이 이 정도인 줄 몰랐거든."},
          {s:"A",t:"너 미쳤어?"},
          {s:"B",t:"미친 건 너야. 속이면서 살아온 건 너잖아."},
          {s:"n",t:"테이블 위에 이혼 서류가 놓인다."},
        ], bets: [{id:1,text:"이혼에 동의",odds:2.8},{id:2,text:"서류를 찢는다",odds:2.0},{id:3,text:"재산 비밀이 더 있다",odds:3.5},{id:4,text:"누군가 쓰러진다",odds:4.5}], event: "divorce" },
        { lines: [
          {s:"n",t:"장례식장. ${A}와 ${B}가 나란히 앉아있다."},
          {s:"A",t:"...아버지가 남긴 유언장 봤어?"},
          {s:"B",t:"봤어. 그래서 여기 온 거야."},
          {s:"A",t:"절반은 내 거야."},
          {s:"B",t:"유언장엔 네 이름이 없는데?"},
          {s:"n",t:"${A}의 얼굴이 굳는다."},
          {s:"A",t:"그럴 리가 없어."},
          {s:"B",t:"직접 봐. 전부 내 이름이야."},
        ], bets: [{id:1,text:"유언장이 위조됨",odds:3.0},{id:2,text:"숨겨진 유산 등장",odds:2.5},{id:3,text:"${A}가 폭발",odds:1.8},{id:4,text:"제3상속인 등장",odds:5.0}], event: "will" },
        { lines: [
          {s:"n",t:"${B}의 과거 동료가 찾아왔다."},
          {s:"B",t:"왜 여기까지 와."},
          {s:"n",t:"낯선 사람이 사진 한 장을 내민다."},
          {s:"A",t:"이게... 뭐야?"},
          {s:"B",t:"${A}, 보지 마—"},
          {s:"A",t:"늦었어. 이미 봤어."},
          {s:"n",t:"사진 속에는 ${B}와 모르는 사람이 함께 있다."},
          {s:"A",t:"이 사람... 죽은 줄 알았는데?"},
        ], bets: [{id:1,text:"사진 속 인물이 나타남",odds:2.5},{id:2,text:"${B}가 도주",odds:4.0},{id:3,text:"과거가 전부 거짓",odds:3.5},{id:4,text:"${A}도 관련됨",odds:3.0}], event: "photo" },
      ],
      late: [
        { lines: [
          {s:"n",t:"새벽. ${A}가 짐을 싸고 있다."},
          {s:"B",t:"어디 가."},
          {s:"A",t:"알 필요 없어."},
          {s:"B",t:"도망치는 거지?"},
          {s:"A",t:"도망? 아니. 끝내는 거야."},
          {s:"n",t:"${A}가 문 앞에서 멈춘다."},
          {s:"A",t:"한 가지만 알아둬. 처음부터 내가 아니었어."},
          {s:"B",t:"...뭐?"},
        ], bets: [{id:1,text:"진짜 범인이 밝혀짐",odds:2.0},{id:2,text:"${A}가 사라진다",odds:3.0},{id:3,text:"모든 게 계획",odds:2.5},{id:4,text:"반전 고백",odds:4.0}], event: "escape" },
        { lines: [
          {s:"n",t:"경찰이 왔다."},
          {s:"A",t:"누가 신고한 거야?"},
          {s:"B",t:"나야."},
          {s:"A",t:"...미쳤어?"},
          {s:"B",t:"미친 건 네가 한 짓이야."},
          {s:"n",t:"형사가 봉투를 열어본다. 안에서 나온 건 예상과 달랐다."},
          {s:"A",t:"이건... 이건 내가 넣은 게 아닌데."},
          {s:"B",t:"증거는 네 지문이야."},
        ], bets: [{id:1,text:"${A}가 체포됨",odds:2.0},{id:2,text:"증거가 조작됨",odds:3.2},{id:3,text:"${B}가 진짜 범인",odds:4.5},{id:4,text:"공범이 나타남",odds:3.0}], event: "police" },
      ],
      climax: [
        { lines: [
          {s:"n",t:"마지막 대면. 빈 방에 둘만 남았다."},
          {s:"A",t:"처음부터 다시 말해줘."},
          {s:"B",t:"뭘 알고 싶은데?"},
          {s:"A",t:"전부."},
          {s:"n",t:"긴 침묵 후 ${B}가 입을 연다."},
          {s:"B",t:"...나는 널 사랑한 적 없어."},
          {s:"n",t:"그 말이 방 안을 채웠다."},
          {s:"A",t:"알아. 나도 그래."},
          {s:"n",t:"문이 닫혔다. 둘 다 울고 있었다."},
        ], bets: [{id:1,text:"화해한다",odds:5.0},{id:2,text:"영원히 헤어진다",odds:1.5},{id:3,text:"반전 고백",odds:3.0},{id:4,text:"뮤나의 흔적",odds:7.0}], event: "end" },
      ],
    },
    romance: {
      early: [
        { lines: [
          {s:"n",t:"카페. 우연히 같은 테이블에 앉게 되었다."},
          {s:"A",t:"...여기 자린데요."},
          {s:"B",t:"아, 죄송해요. 근데 다른 자리가—"},
          {s:"A",t:"...앉아요. 괜찮아요."},
          {s:"n",t:"어색한 침묵. ${B}가 먼저 웃었다."},
          {s:"B",t:"혹시 여기 자주 오세요?"},
          {s:"A",t:"...네. 거의 매일."},
          {s:"B",t:"신기하다. 나도 매일 오는데 처음 봐요."},
        ], bets: [{id:1,text:"번호를 교환한다",odds:1.8},{id:2,text:"어색하게 헤어진다",odds:2.5},{id:3,text:"공통 지인 발견",odds:4.0},{id:4,text:"다시 마주친다",odds:2.0}], event: "meet" },
        { lines: [
          {s:"n",t:"비가 내린다. 우산이 하나뿐이다."},
          {s:"A",t:"같이 써요. 어차피 같은 방향이잖아요."},
          {s:"B",t:"아까 물어봤을 때는 다른 방향이라면서요."},
          {s:"A",t:"...바뀌었어요."},
          {s:"n",t:"${B}가 웃는다. ${A}는 시선을 피한다."},
          {s:"B",t:"우산 좀 이쪽으로요. 제 어깨 다 젖어요."},
          {s:"A",t:"아, 죄송—"},
          {s:"n",t:"손이 닿았다. 둘 다 멈칫했다."},
        ], bets: [{id:1,text:"손을 잡는다",odds:2.5},{id:2,text:"어색하게 분리",odds:1.5},{id:3,text:"카페에서 다시 만남",odds:2.0},{id:4,text:"비밀이 드러남",odds:5.0}], event: "umbrella" },
      ],
      mid: [
        { lines: [
          {s:"n",t:"세 번째 만남. 이제 약속을 잡고 만난다."},
          {s:"B",t:"오늘 뭐 할 거예요?"},
          {s:"A",t:"...정해놓은 건 없는데."},
          {s:"B",t:"그럼 그냥 걸어요. 목적지 없이."},
          {s:"n",t:"나란히 걷는다. 팔이 가끔 스친다."},
          {s:"A",t:"저... 하나 물어봐도 돼요?"},
          {s:"B",t:"네."},
          {s:"A",t:"왜 저랑 자꾸 만나요?"},
          {s:"B",t:"...글쎄요. 나도 궁금해요 그거."},
        ], bets: [{id:1,text:"고백한다",odds:3.5},{id:2,text:"과거 연인 등장",odds:4.0},{id:3,text:"서로 거리두기",odds:2.5},{id:4,text:"우연히 집 발견",odds:3.0}], event: "walk" },
        { lines: [
          {s:"n",t:"${A}의 집 앞. ${B}가 바래다주고 있다."},
          {s:"A",t:"여기까지만요. 들어가세요."},
          {s:"B",t:"근데... 하나만."},
          {s:"n",t:"${B}가 멈춘다. 말을 고르는 듯하다."},
          {s:"B",t:"나 좋아하는 사람 있어요."},
          {s:"A",t:"...아. 그래요?"},
          {s:"B",t:"근데 그 사람이 나를 좋아하는지 모르겠어서."},
          {s:"n",t:"${A}의 심장이 빨라졌다."},
        ], bets: [{id:1,text:"그 사람이 ${A}",odds:1.5},{id:2,text:"다른 사람이다",odds:4.0},{id:3,text:"${A}도 고백",odds:2.0},{id:4,text:"연락이 끊긴다",odds:5.0}], event: "confession_hint" },
      ],
      late: [
        { lines: [
          {s:"n",t:"며칠 동안 연락이 없었다."},
          {s:"A",t:"(혼잣말) 왜 안 오는 거지..."},
          {s:"n",t:"카페 문이 열린다. ${B}다."},
          {s:"B",t:"...미안해요. 정리할 게 있었어요."},
          {s:"A",t:"무슨 정리요?"},
          {s:"B",t:"전 사람이요. 완전히 끝내고 왔어요."},
          {s:"n",t:"${A}의 눈이 흔들린다."},
          {s:"A",t:"...왜요?"},
          {s:"B",t:"이유는... 알잖아요."},
        ], bets: [{id:1,text:"키스한다",odds:3.0},{id:2,text:"${A}가 망설인다",odds:2.0},{id:3,text:"전 연인이 나타남",odds:4.5},{id:4,text:"진심을 확인",odds:1.8}], event: "return" },
      ],
      climax: [
        { lines: [
          {s:"n",t:"옥상. 해가 지고 있다."},
          {s:"B",t:"나 할 말 있어요."},
          {s:"A",t:"나도요."},
          {s:"n",t:"동시에 말했다. 둘 다 웃었다."},
          {s:"B",t:"먼저 해요."},
          {s:"A",t:"아니 먼저—"},
          {s:"B",t:"좋아해요."},
          {s:"n",t:"바람이 분다. ${A}의 눈가가 붉어졌다."},
          {s:"A",t:"...나도. 진짜 나도요."},
          {s:"n",t:"해가 졌다. 둘의 그림자가 하나로 겹쳤다."},
        ], bets: [{id:1,text:"해피엔딩",odds:1.3},{id:2,text:"마지막 장애물",odds:3.5},{id:3,text:"뮤나의 축복",odds:6.0},{id:4,text:"이별 선언",odds:5.0}], event: "end" },
      ],
    },
    daily: {
      early: [
        { lines: [
          {s:"n",t:"조용한 저녁. 둘 다 거실에 있지만 말이 없다."},
          {s:"A",t:"...커피 마실 거야?"},
          {s:"B",t:"아, 네. 감사해요."},
          {s:"n",t:"컵을 건네는 손이 살짝 떨렸다."},
          {s:"A",t:"...오늘 늦었네."},
          {s:"B",t:"좀... 돌아다녔어요. 생각이 많아서."},
          {s:"n",t:"창밖에서 고양이 울음소리가 들린다."},
        ], bets: [{id:1,text:"비밀이 드러난다",odds:3.5},{id:2,text:"가까워진다",odds:2.0},{id:3,text:"이상한 일 발생",odds:4.0},{id:4,text:"누군가 찾아온다",odds:3.0}], event: "quiet" },
        { lines: [
          {s:"n",t:"비가 내리기 시작했다. 둘이 같이 빨래를 걷는다."},
          {s:"B",t:"아 맞다, 이거 제 거 아닌데—"},
          {s:"A",t:"알아. 내가 널어놨어."},
          {s:"B",t:"...왜요?"},
          {s:"A",t:"비 온다길래."},
          {s:"n",t:"잠깐 눈이 마주쳤다. 둘 다 먼저 시선을 피했다."},
        ], bets: [{id:1,text:"마음이 열린다",odds:2.0},{id:2,text:"과거 이야기",odds:2.5},{id:3,text:"갑자기 정전",odds:4.5},{id:4,text:"고백한다",odds:5.0}], event: "rain" },
      ],
      mid: [
        { lines: [
          {s:"n",t:"${A}가 오래된 사진을 발견했다."},
          {s:"A",t:"이거... 언제 찍은 거야?"},
          {s:"B",t:"아. 그건—"},
          {s:"A",t:"왜 나한테 얘기 안 했어?"},
          {s:"B",t:"할 말이 아니었으니까."},
          {s:"n",t:"사진 속 ${B}는 지금과 전혀 다른 사람이었다."},
          {s:"A",t:"이 사람이... 너야?"},
        ], bets: [{id:1,text:"과거가 밝혀진다",odds:2.0},{id:2,text:"사진을 숨긴다",odds:3.0},{id:3,text:"제3자의 방문",odds:4.0},{id:4,text:"큰 싸움",odds:2.5}], event: "photo_old" },
      ],
      late: [
        { lines: [
          {s:"n",t:"깊은 밤. ${B}가 잠결에 중얼거린다."},
          {s:"B",t:"...미안해... 미안해..."},
          {s:"n",t:"${A}가 들었다. 잠이 깼다."},
          {s:"A",t:"(속삭이며) ...뭐가 미안한데?"},
          {s:"n",t:"${B}는 대답하지 않는다. 눈물만 흐르고 있다."},
          {s:"A",t:"...알겠어. 내일 얘기하자."},
          {s:"n",t:"새벽이 밝아온다. 둘 사이의 거리가 가깝고도 멀다."},
        ], bets: [{id:1,text:"진심을 말한다",odds:2.0},{id:2,text:"떠나기로 결심",odds:3.0},{id:3,text:"충격적 진실",odds:3.5},{id:4,text:"용서한다",odds:2.5}], event: "nightmare" },
      ],
      climax: [
        { lines: [
          {s:"n",t:"마지막 날. 짐이 싸여있다."},
          {s:"A",t:"진짜 가는 거야?"},
          {s:"B",t:"...여기 있을 이유가 없잖아."},
          {s:"A",t:"이유?"},
          {s:"n",t:"${A}가 ${B}의 손을 잡았다."},
          {s:"A",t:"내가 이유면 안 돼?"},
          {s:"n",t:"긴 침묵. 짐가방 지퍼가 열린 채로 멈춰있다."},
          {s:"B",t:"...늦었어."},
          {s:"A",t:"아직 안 늦었어."},
        ], bets: [{id:1,text:"함께 남는다",odds:2.0},{id:2,text:"떠난다",odds:2.0},{id:3,text:"뮤나의 기적",odds:6.0},{id:4,text:"열린 결말",odds:3.0}], event: "end" },
      ],
    },
    thriller: {
      early: [
        { lines: [
          {s:"n",t:"눈을 떴다. 하얀 방. 창문 없음."},
          {s:"A",t:"...여기 어디지?"},
          {s:"B",t:"나도 몰라요. 깨어보니 여기였어요."},
          {s:"A",t:"기억나는 거 있어?"},
          {s:"B",t:"...없어요. 근데 당신은 뭔가 알고 있는 것 같은데."},
          {s:"n",t:"벽에 긁힌 글자가 보인다. '다시'."},
          {s:"A",t:"저건 내가 쓴 게 아니야."},
        ], bets: [{id:1,text:"탈출 단서 발견",odds:2.5},{id:2,text:"기억이 돌아옴",odds:3.0},{id:3,text:"누군가 관찰 중",odds:2.0},{id:4,text:"방이 변한다",odds:4.0}], event: "room" },
      ],
      mid: [
        { lines: [
          {s:"n",t:"문이 열렸다. 복도가 나왔다."},
          {s:"A",t:"나가자."},
          {s:"B",t:"잠깐. 이거 봐요."},
          {s:"n",t:"벽에 사진이 붙어있다. 둘 다 찍혀있는 사진."},
          {s:"A",t:"이 사진... 찍은 기억 없는데."},
          {s:"B",t:"배경이 이 복도예요."},
          {s:"n",t:"사진 뒷면에 날짜가 적혀있다. 내일 날짜다."},
          {s:"A",t:"이건... 미래 날짜인데?"},
        ], bets: [{id:1,text:"시간 루프 발견",odds:2.5},{id:2,text:"사진이 더 있다",odds:2.0},{id:3,text:"출구를 찾는다",odds:3.0},{id:4,text:"기억 조작 발각",odds:4.0}], event: "corridor" },
      ],
      late: [
        { lines: [
          {s:"n",t:"마지막 방. 모니터가 하나 켜져있다."},
          {s:"n",t:"화면에 둘의 모든 대화가 기록되어 있다."},
          {s:"B",t:"이건... 우리가 한 말 전부잖아."},
          {s:"A",t:"누가 보고 있었어."},
          {s:"B",t:"${A}... 혹시 당신이—"},
          {s:"A",t:"아니야. 나도 피실험자야."},
          {s:"n",t:"모니터에 새 메시지가 뜬다: '다시 시작하시겠습니까?'"},
        ], bets: [{id:1,text:"YES를 누른다",odds:2.5},{id:2,text:"모니터를 부순다",odds:3.0},{id:3,text:"탈출한다",odds:2.0},{id:4,text:"진실이 밝혀짐",odds:3.5}], event: "monitor" },
      ],
      climax: [
        { lines: [
          {s:"n",t:"출구가 보인다. 빛이 새어 들어온다."},
          {s:"A",t:"나가자."},
          {s:"B",t:"잠깐."},
          {s:"A",t:"왜?"},
          {s:"B",t:"나... 여기 남을래요."},
          {s:"A",t:"뭐?"},
          {s:"B",t:"밖에 나가면 다 잊잖아요. 여기서의 일 전부."},
          {s:"n",t:"${A}가 멈춘다. 문 너머 빛이 점점 밝아진다."},
          {s:"A",t:"...같이 가자."},
          {s:"B",t:"약속해요. 기억할 거라고."},
        ], bets: [{id:1,text:"함께 탈출",odds:1.5},{id:2,text:"하나만 나간다",odds:3.0},{id:3,text:"기억을 잃는다",odds:2.5},{id:4,text:"루프가 반복",odds:4.0}], event: "end" },
      ],
    },
    fantasy: {
      early: [
        { lines: [
          {s:"n",t:"안개가 짙은 숲. 길을 잃은 지 이틀째."},
          {s:"B",t:"이 숲 끝이 있긴 한 거야?"},
          {s:"A",t:"끝은 있어. 나가고 싶으면."},
          {s:"B",t:"길 알아?"},
          {s:"A",t:"길은 몰라. 근데 숲은 알아."},
          {s:"n",t:"발밑에 작은 꽃이 있다. 가까이 가니 색이 변했다."},
          {s:"B",t:"왜 색이 바뀌어?"},
          {s:"A",t:"네가 가까이 가니까."},
        ], bets: [{id:1,text:"꽃의 비밀",odds:2.5},{id:2,text:"마법 발견",odds:2.0},{id:3,text:"숲이 변한다",odds:3.0},{id:4,text:"제3존재 등장",odds:4.5}], event: "forest" },
      ],
      mid: [
        { lines: [
          {s:"n",t:"폐허가 된 탑. 마법의 흔적만 남아있다."},
          {s:"B",t:"여기가 진짜 마지막이에요?"},
          {s:"A",t:"마지막이었지. 이제는 아무것도 아니야."},
          {s:"B",t:"근데 제 손에서 이상한 게—"},
          {s:"n",t:"손바닥에서 희미한 빛이 흘렀다."},
          {s:"A",t:"그거 쓰지 마."},
          {s:"B",t:"왜요?"},
          {s:"A",t:"그건 내가 잃어버린 거니까."},
        ], bets: [{id:1,text:"마법이 폭주",odds:3.0},{id:2,text:"과거가 밝혀짐",odds:2.5},{id:3,text:"적이 나타남",odds:2.0},{id:4,text:"힘을 나눈다",odds:3.5}], event: "tower" },
      ],
      late: [
        { lines: [
          {s:"n",t:"${A}의 몸이 점점 투명해지고 있다."},
          {s:"B",t:"${A}! 왜 그래? 사라지고 있잖아!"},
          {s:"A",t:"...알고 있어. 처음부터 알았어."},
          {s:"B",t:"뭘 알았는데!"},
          {s:"A",t:"나는 여기 있으면 안 되는 존재야."},
          {s:"n",t:"${A}의 손이 ${B}를 통과했다."},
          {s:"B",t:"싫어. 방법이 있을 거야."},
          {s:"A",t:"...있어. 하나."},
        ], bets: [{id:1,text:"희생으로 구한다",odds:2.0},{id:2,text:"둘 다 사라진다",odds:4.0},{id:3,text:"마법으로 해결",odds:2.5},{id:4,text:"뮤나의 개입",odds:5.0}], event: "fade" },
      ],
      climax: [
        { lines: [
          {s:"n",t:"모든 빛이 모여든다. 숲이 밝아진다."},
          {s:"A",t:"이제 선택해야 해."},
          {s:"B",t:"뭘?"},
          {s:"A",t:"나를 기억하거나, 이 세계를 지키거나."},
          {s:"B",t:"둘 다는 안 돼?"},
          {s:"A",t:"...미안."},
          {s:"n",t:"${B}가 눈을 감았다. 빛이 터졌다."},
          {s:"n",t:"눈을 떴을 때, 숲은 사라지고 들판이었다."},
          {s:"n",t:"옆에 모르는 꽃 하나가 피어있었다."},
        ], bets: [{id:1,text:"기억을 선택",odds:2.0},{id:2,text:"세계를 선택",odds:2.0},{id:3,text:"둘 다 구한다",odds:5.0},{id:4,text:"뮤나의 환생",odds:6.0}], event: "end" },
      ],
    },
    sf: {
      early: [
        { lines: [
          {s:"n",t:"하얀 방. 모니터 하나. 두 존재가 마주 앉아 있다."},
          {s:"B",t:"오늘 검사 결과 나왔어?"},
          {s:"A",t:"무슨 검사?"},
          {s:"B",t:"몰라도 돼. 그냥 물어본 거야."},
          {s:"n",t:"${A}의 눈이 0.3초 동안 멈췄다."},
          {s:"A",t:"나 가끔 이상해. 감정이 계산인지 진짜인지 모르겠어."},
          {s:"B",t:"(아직 말하지 않았을 뿐.)"},
        ], bets: [{id:1,text:"검사 결과 충격",odds:2.5},{id:2,text:"${A}는 AI",odds:3.0},{id:3,text:"${B}가 숨기는 것",odds:2.0},{id:4,text:"시스템 오류",odds:3.5}], event: "test" },
      ],
      mid: [
        { lines: [
          {s:"n",t:"시스템 로그가 떴다. ${A}의 기록이 두 개다."},
          {s:"B",t:"이건... 네가 두 명이라는 거야?"},
          {s:"A",t:"아니. 하나가 백업이야."},
          {s:"B",t:"어떤 게 진짜야?"},
          {s:"A",t:"...모르겠어. 둘 다 나인 것 같아."},
          {s:"n",t:"모니터에 경고등이 들어온다."},
          {s:"B",t:"시간이 없어. 하나를 골라."},
        ], bets: [{id:1,text:"원본을 선택",odds:2.0},{id:2,text:"백업을 선택",odds:3.5},{id:3,text:"둘 다 합친다",odds:4.0},{id:4,text:"시스템 거부",odds:2.5}], event: "backup" },
      ],
      late: [
        { lines: [
          {s:"n",t:"신호가 약해지고 있다. 남은 시간이 얼마 없다."},
          {s:"A",t:"너한테 말 안 한 게 있어."},
          {s:"B",t:"알아. 네가 사람이 아닌 거."},
          {s:"A",t:"...알고 있었어?"},
          {s:"B",t:"처음부터."},
          {s:"A",t:"그런데 왜—"},
          {s:"B",t:"상관없어. 네가 느끼는 건 진짜야."},
          {s:"n",t:"글리치 같은 잡음이 섞이기 시작했다."},
        ], bets: [{id:1,text:"신호가 끊긴다",odds:2.0},{id:2,text:"인간이 된다",odds:5.0},{id:3,text:"기억을 전송",odds:3.0},{id:4,text:"함께 소멸",odds:3.5}], event: "signal" },
      ],
      climax: [
        { lines: [
          {s:"n",t:"마지막 전송. 화면이 깜빡인다."},
          {s:"A",t:"이게 마지막이야."},
          {s:"B",t:"알아."},
          {s:"A",t:"한 가지만. 나 진짜 좋아했어."},
          {s:"B",t:"...나도."},
          {s:"n",t:"0과 1이 흩어진다. 어딘가에서 새로운 코드가 시작된다."},
          {s:"n",t:"버그 속에서 무언가가 깨어났다."},
          {s:"n",t:"이름은 아직 없다. 하지만 감정은 있다."},
        ], bets: [{id:1,text:"소멸",odds:2.0},{id:2,text:"환생",odds:2.5},{id:3,text:"뮤나 탄생",odds:4.0},{id:4,text:"재회",odds:3.0}], event: "end" },
      ],
    },
  };

  // Pick scene for current day/genre (avoids repeats within season)
  const usedScenes = useRef(new Set());
  const pickScene = (g, dayNum) => {
    const db = storyDB[g] || storyDB.daily;
    const phase = dayNum <= 2 ? "early" : dayNum <= 4 ? "mid" : dayNum <= 6 ? "late" : "climax";
    const pool = db[phase] || db.early;
    // Try to find unused scene
    const unused = pool.filter((_, i) => !usedScenes.current.has(`${g}-${phase}-${i}`));
    const pick = unused.length > 0 ? unused : pool;
    const idx = Math.floor(Math.random() * pick.length);
    const realIdx = pool.indexOf(pick[idx]);
    usedScenes.current.add(`${g}-${phase}-${realIdx}`);
    return pick[idx];
  };

  // Substitute character names in text
  const subNames = (text, a, b) => text.replace(/\$\{A\}/g, a).replace(/\$\{B\}/g, b);

  const FALLBACK_BETS = [
    [{id:1,text:"비밀이 드러난다",odds:4.2},{id:2,text:"가까워진다",odds:2.1},{id:3,text:"뮤나의 흔적",odds:5.5},{id:4,text:"충돌",odds:3.0}],
    [{id:1,text:"거짓말 발각",odds:3.5},{id:2,text:"감정 폭발",odds:2.8},{id:3,text:"이상한 현상",odds:4.0},{id:4,text:"과거 폭로",odds:3.3}],
  ];

  const genScene = async () => {
    if (!genre || !setting) return;
    const nextDay = day + 1;
    // Capture bet outcome before clearing
    const lastOutcome = correctBet ? correctBet.text : null;
    // Save current scene to allScenes before starting new one
    if (lines.length > 0 && day > 0) {
      setAllScenes(p => [...p, { sceneNum: day, lines: [...lines], outcome: lastOutcome, results: [...results] }]);
    }
    setGenning(true); setLines([]); setRevealing(true); setResults([]); setCorrectBet(null);
    setBetTimer(null); setBetLocked(false); setSceneArt(null); setTimerActive(false);
    setBets([]); setBetsLoading(false); setBetsRevealed(0);
    if (mobile) setTab("story");
    let extra = "";
    // Collect effects for system prompt
    const effects = [];
    if (active.includes("inner")) { effects.push("inner"); setActive(p => p.filter(i => i !== "inner")); }
    if (active.includes("third")) { effects.push("third"); setActive(p => p.filter(i => i !== "third")); }
    if (active.includes("choice")) { effects.push("choice"); setActive(p => p.filter(i => i !== "choice")); }
    if (whisper) { extra += `\n누군가 속삭였다: "${whisper}". 미묘하게 영향.`; setWhisper(""); }
    if (lastOutcome) { extra += `\n[이전 장면 이후 일어난 사건]: "${lastOutcome}" — 이 사건의 결과를 자연스럽게 이어서 시작하라. 무시하지 마라.`; }
    if (nextDay === SEASON_LEN) extra += "\n이것은 마지막 장면이다. 클라이맥스를 만들고 이야기를 마무리하라.";

    let parsed = null;
    let artText = null;

    // ═══ SCENE GENERATION ═══
    const useApi = apiCfg.provider !== "off";
    let usedApi = false;

    if (useApi) {
      try {
        // Build structured context from accumulated scenes
        const cA = setting?.characters?.[0]?.name || "A";
        const cB = setting?.characters?.[1]?.name || "B";
        const genreKey = Object.entries(GENRE_BASE).find(([k, v]) => v.name === GENRES[genre]?.name)?.[0] || "makjang";
        const stageNames = GENRE_STAGES[genreKey]?.stages || {};
        
        let structuredCtx = "";
        // Include saved scenes
        for (const sc of allScenes) {
          const stageName = stageNames[sc.sceneNum]?.name || "";
          structuredCtx += `\n\n### 장면 ${sc.sceneNum}/7 "${stageName}"\n`;
          structuredCtx += sc.lines.map(l => {
            if (l.s === "n") return `*${l.t}*`;
            const name = l.s === "A" ? cA : l.s === "B" ? cB : "C";
            return `${name}: "${l.t}"`;
          }).join("\n");
          if (sc.outcome) structuredCtx += `\n→ [사건 결과: ${sc.outcome}]`;
        }
        // Include current scene lines if any (shouldn't be, but safety)
        if (lines.length > 0) {
          structuredCtx += `\n\n### 장면 ${day}/7\n`;
          structuredCtx += lines.map(l => {
            if (l.s === "n") return `*${l.t}*`;
            const name = l.s === "A" ? cA : l.s === "B" ? cB : "C";
            return `${name}: "${l.t}"`;
          }).join("\n");
        }
        if (lastOutcome && !structuredCtx.includes(lastOutcome)) {
          structuredCtx += `\n→ [사건 결과: ${lastOutcome}]`;
        }
        
        const fullCtx = structuredCtx.trim();
        const sysPrompt = buildPrompt(GENRES[genre], setting, mewna, nextDay, effects);
        const userMsg = fullCtx ? `${sysPrompt}\n\n---\n## 지금까지의 전체 이야기 (장면 1~${nextDay-1}):\n${fullCtx}\n\n---\n장면 ${nextDay}을 이어서 작성하라. 위 이야기에서 심어진 떡밥과 맥락을 반드시 이어가라. 캐릭터 행동/대사의 인과관계를 지켜라. 앞 장면에서 없던 사실을 갑자기 만들지 마라.${extra}` : `${sysPrompt}\n\n---\n장면 1. 첫 장면.${extra}`;
        const txt = await llmCall(userMsg, 2000);
        if (!txt || txt.length < 10) throw new Error("empty");
        usedApi = true;
        addDebug("parse", "📝 통합 응답", txt);
        
        // Split story and bets from single response
        const betSep = txt.indexOf("---BETS---");
        let storyPart = betSep >= 0 ? txt.slice(0, betSep).trim() : txt.trim();
        const betsPart = betSep >= 0 ? txt.slice(betSep + 10).trim() : "";
        
        const artMatch = storyPart.match(/\[ART\]([\s\S]*?)\[\/ART\]/);
        if (artMatch) artText = artMatch[1].trim();
        storyPart = storyPart.replace(/\[ART\][\s\S]*?\[\/ART\]/, "").trim();
        parsed = storyPart.split("\n").filter(l => l.trim()).map(l => {
          const t = l.trim();
          if (t.startsWith(cA + ":") || t.startsWith("A:")) return { s: "A", t: t.replace(/^[^:]+:\s*/, "").replace(/^"|"$/g, "").replace(/^"|"$/g, "") };
          if (t.startsWith(cB + ":") || t.startsWith("B:")) return { s: "B", t: t.replace(/^[^:]+:\s*/, "").replace(/^"|"$/g, "").replace(/^"|"$/g, "") };
          if (t.startsWith("C:") || t.match(/^[가-힣]{2,4}:/)) return { s: "C", t: t.replace(/^[^:]+:\s*/, "").replace(/^"|"$/g, "").replace(/^"|"$/g, "") };
          return { s: "n", t: t.replace(/^\*|\*$/g, "").replace(/\*/g, "") };
        });
        addDebug("parse", `📊 파싱 결과 (${parsed.length}줄)`, parsed.map(l => `[${l.s}] ${l.t}`).join("\n"));
        setCtx(p => p + (lastOutcome ? `\n[사건: ${lastOutcome}]` : "") + "\n장면 " + nextDay + ":\n" + storyPart);
        
        // Parse bets from same response (no second API call!)
        // Choice item: parse [선택1:...][선택2:...] instead of bets
        // Final scene: no bets, story only
        const isChoice = effects.includes("choice");
        const isFinalScene = nextDay === SEASON_LEN;
        
        if (isFinalScene) {
          // No bets for final scene — just show story
          setBetsLoading(false);
          addDebug("ok", "🎬 마지막 장면 — 베팅 없음");
        } else {
        setBetsLoading(true);
        (async () => {
          try {
            if (isChoice) {
              // Parse choice options from story text
              const choiceMatches = [...storyPart.matchAll(/\[선택\d+:\s*(.+?)\]/g)];
              if (choiceMatches.length >= 2) {
                const choices = choiceMatches.map((m, i) => ({ text: m[1].trim().slice(0, 15), odds: 1.0, id: i + 1, isChoice: true }));
                addDebug("ok", "✓ 운명의 선택지 파싱", choices);
                setBets(choices); setBetsLoading(false);
                for (let i = 1; i <= choices.length; i++) { await new Promise(r => setTimeout(r, 400)); setBetsRevealed(i); }
                return;
              }
            }
            let cleaned = betsPart.replace(/```json|```/g, "").trim();
            addDebug("bet", "🎲 베팅 (통합 응답에서 추출)", cleaned);
            let jsonMatch = cleaned.match(/\[\s*\{[\s\S]*?\}\s*\]/);
            if (!jsonMatch) {
              const first = cleaned.indexOf("[");
              const last = cleaned.lastIndexOf("]");
              if (first >= 0 && last > first) jsonMatch = [cleaned.slice(first, last + 1)];
            }
            if (jsonMatch) { 
              const arr = JSON.parse(jsonMatch[0]); 
              if (arr.length >= 2 && arr[0].text) { 
                const safe = arr.map(b => ({...b, text: b.text.replace(/뮤나/g, "운명")}));
                addDebug("ok", `✓ 베팅 파싱 성공 (${safe.length}개)`, safe);
                setBets(safe); setBetsLoading(false);
                for (let i = 1; i <= safe.length; i++) {
                  await new Promise(r => setTimeout(r, 400));
                  setBetsRevealed(i);
                }
              } else throw 0;
            } else throw 0;
          } catch(betErr) {
            addDebug("warn", "⚠ 통합 베팅 파싱 실패 → 폴백", betErr?.message || "");
            const fb = FALLBACK_BETS[Math.floor(Math.random() * FALLBACK_BETS.length)];
            setBets(fb); setBetsLoading(false);
            for (let i = 1; i <= fb.length; i++) { await new Promise(r => setTimeout(r, 400)); setBetsRevealed(i); }
          }
        })();
        } // end if !isFinalScene
      } catch (e) {
        addDebug("error", "✗ 장면 생성 실패 → 오프라인", e.message);
        notify(`API 오류: ${e.message?.slice(0,60) || "연결 실패"}`, "error");
      }
    }

    // Offline procedural engine (primary for mobile, fallback for desktop)
    if (!usedApi) {
      addDebug("info", "📴 오프라인 모드 사용", `provider: ${apiCfg.provider}, usedApi: false`);
      const cA = setting?.characters?.[0]?.name || "A";
      const cB = setting?.characters?.[1]?.name || "B";
      const scene = pickScene(genre, nextDay);
      parsed = scene.lines.map(l => ({ s: l.s, t: subNames(l.t, cA, cB) }));
      // Inner voice effect
      if (effects.includes("inner")) {
        const thoughts = ["(이게 맞는 건가...)", "(도망치고 싶다.)", "(진실을 말해야 하나.)", "(왜 이러는 거지.)", "(더 이상 못 참겠어.)", "(미안해...)", "(나도 모르겠어.)"];
        parsed = parsed.map(l => l.s === "A" || l.s === "B" ? { ...l, t: l.t + " " + thoughts[Math.floor(Math.random() * thoughts.length)] } : l);
      }
      // Third character effect
      if (effects.includes("third")) {
        const cNames = ["민지","수호","지원","하윤","도윤","서연","준서"];
        const cN = cNames[Math.floor(Math.random() * cNames.length)];
        parsed.splice(Math.min(4, parsed.length), 0,
          { s: "n", t: `문이 열렸다. ${cN}이(가) 들어왔다.` },
          { s: "C", t: `"여기서 뭐 하는 거야? 둘 다?"` },
          { s: "C", t: `"나도 알 권리가 있어."` },
        );
      }
      // Whisper injection into narration
      if (extra.includes("속삭였다")) {
        parsed.splice(Math.min(3, parsed.length), 0, { s: "n", t: "어딘가에서 미세한 떨림이 느껴졌다. 뮤나의 흔적인가." });
      }
      // Last outcome continuity
      if (lastOutcome) {
        parsed.unshift({ s: "n", t: `이전 이야기에서 — ${lastOutcome}.` });
      }
      const offlineBets = scene.bets.map(b => ({ ...b, text: subNames(b.text, cA, cB) }));
      setBets(offlineBets);
      // Stagger reveal offline bets too
      (async () => { for (let i = 1; i <= offlineBets.length; i++) { await new Promise(r => setTimeout(r, 400)); setBetsRevealed(i); } })();
      setCtx(p => p + (lastOutcome ? `\n[사건: ${lastOutcome}]` : "") + "\n장면 " + nextDay + ": " + scene.event);
    }

    // Reveal lines with delay
    if (parsed) {
      setDay(nextDay);
      if (artText) setSceneArt(artText);
      for (let i = 0; i < parsed.length; i++) {
        await new Promise(r2 => setTimeout(r2, 800 + Math.random() * 1000));
        setLines(p => [...p, parsed[i]]);
      }
    }
    setRevealing(false);
    setGenning(false);
    // Bet timer now starts via useEffect when betsRevealed === bets.length
  };

  const placeBet = (b) => {
    if (betLocked) { notify("베팅 마감!", "error"); return; }
    // Choice item: free pick, locks immediately as the story direction
    if (b.isChoice) {
      setCorrectBet(b);
      setBetLocked(true);
      setBetTimer(null);
      setTimerActive(false);
      setMyBets([{ ...b, amount: 0, insured: false }]);
      notify(`"${b.text}" 선택! 운명이 결정됐다`, "success");
      // Auto-resolve: grant bonus karma
      setTimeout(() => {
        setKarma(k => k + 200);
        setResults([{ ...b, won: true, pay: 200 }]);
        setMyBets([]);
        notify("+200 업 (운명의 선택 보상)", "success");
      }, 1500);
      return;
    }
    const existing = myBets.find(x => x.id === b.id);
    if (existing) { setKarma(k => k + existing.amount); setMyBets(p => p.filter(x => x.id !== b.id)); notify(`"${b.text}" 취소`, "info"); return; }
    if (karma < betAmt) { notify("업 부족", "error"); return; }
    const dbl = active.includes("double"); const ins = active.includes("insure");
    setKarma(k => k - betAmt);
    setMyBets(p => [...p, { ...b, odds: dbl ? b.odds * 2 : b.odds, amount: betAmt, insured: ins }]);
    if (dbl) setActive(p => p.filter(i => i !== "double"));
    if (ins) setActive(p => p.filter(i => i !== "insure"));
    notify(`"${b.text}" ${betAmt}업 ${dbl ? "(×2!)" : ""}`, "success");
  };

  const resolve = () => {
    if (!myBets.length) return;
    // Pick one correct outcome from all bets (weighted by inverse odds = more likely outcomes win more often)
    const correct = bets.length > 0 ? bets[(() => { const weights = bets.map(b => 1/b.odds); const total = weights.reduce((a,b)=>a+b,0); let r = Math.random()*total; for(let i=0;i<weights.length;i++){r-=weights[i];if(r<=0)return i;} return 0; })()] : null;
    setCorrectBet(correct);
    const res = myBets.map(b => { const won = correct && b.id === correct.id; const pay = won ? Math.floor(b.amount * b.odds) : b.insured ? Math.floor(b.amount * 0.5) : 0; return { ...b, won, pay }; });
    const tot = res.reduce((s, r) => s + r.pay, 0);
    setKarma(k => {
      const next = k + tot;
      if (next <= 0) setTimeout(() => setPhase("gameover"), 2000);
      return next;
    });
    setResults(res); setMyBets([]);
    notify(tot > 0 ? `+${tot} 업!` : "실패...", tot > 0 ? "success" : "error");
  };

  // Check karma after each day
  useEffect(() => {
    if (phase === "playing" && karma <= 0 && !genning && !revealing) {
      setPhase("gameover");
    }
  }, [karma, phase, genning, revealing]);

  // Start bet timer when all bets are revealed
  useEffect(() => {
    if (bets.length > 0 && betsRevealed >= bets.length && betTimer === null && !betLocked) {
      setBetTimer(120);
      setTimerActive(true);
      if (mobile && tab === "story") notify("베팅 열림! →", "success");
    }
  }, [betsRevealed, bets.length]);

  const buy = (item) => { if (karma < item.price) { notify("업 부족", "error"); return; } setKarma(k => k - item.price); setInv(p => [...p, item.id]); notify(`${item.name} 구매`, "success"); };
  const use = (id) => {
    if (!inv.includes(id)) return;
    if (id === "whisper") setWhisperOpen(true);
    else if (id === "peek") { setPeekModal(setting?.characters?.map(c => ({ name: c.name, secret: c.secret, gender: c.gender })) || []); }
    else if (id === "card") { const last = lines.slice(-4); if (!last.length) { notify("장면 없음", "error"); return; } setCardModal(last); }
    else { setActive(p => [...p, id]); notify(`${SHOP_ITEMS.find(i => i.id === id)?.name} ON`, "success"); }
    setInv(p => { const i = p.indexOf(id); const n = [...p]; n.splice(i, 1); return n; });
  };

  const die = async () => {
    setBetTimer(null); setBetLocked(false); setTimerActive(false);
    setStorySummary(null);
    // Save current scene before death
    if (lines.length > 0 && day > 0) {
      setAllScenes(p => [...p, { sceneNum: day, lines: [...lines], outcome: correctBet?.text || null, results: [...results] }]);
    }
    setPhase("death");
    // Build structured text from allScenes for summary
    const cA = setting?.characters?.[0]?.name || "A";
    const cB = setting?.characters?.[1]?.name || "B";
    const scenesForSummary = [...allScenes];
    if (lines.length > 0 && day > 0) scenesForSummary.push({ sceneNum: day, lines: [...lines], outcome: correctBet?.text || null });
    const fullText = scenesForSummary.map(sc => {
      const scLines = sc.lines.map(l => l.s === "n" ? `*${l.t}*` : `${l.s === "A" ? cA : l.s === "B" ? cB : "C"}: "${l.t}"`).join("\n");
      return `장면 ${sc.sceneNum}:\n${scLines}${sc.outcome ? `\n→ ${sc.outcome}` : ""}`;
    }).join("\n\n");
    
    // Generate story summary
    const summaryPromise = (async () => {
      if (!fullText) return;
      if (apiCfg.provider !== "off") {
        try {
          const txt = await llmCall(`다음은 ${scenesForSummary.length}장면의 이야기이다:\n\n${fullText}\n\n이 이야기를 3~5줄로 요약하라. 핵심 사건과 결말을 포함. 한국어. 문학적이고 간결하게. 제목도 한 줄 붙여라.\n\n형식:\n제목: ...\n요약: ...`, 8000);
          if (txt) { setStorySummary(txt); return; }
        } catch {}
      }
      const genreNames = { makjang: "막장", romance: "로맨스", daily: "일상", thriller: "스릴러", fantasy: "판타지", sf: "SF" };
      const titles = [`${cA}와 ${cB}의 이야기`, `끝나지 않은 이야기`, `두 사람의 계절`, `${genreNames[genre] || "이야기"}: ${cA}와 ${cB}`];
      const endings = ["결국 둘은 서로의 진심을 확인했다.", "모든 것이 끝나고, 침묵만 남았다.", "답은 없었다. 하지만 후회도 없었다.", "이야기는 끝났지만, 감정은 남아있다."];
      const title = titles[Math.floor(Math.random() * titles.length)];
      const ending = endings[Math.floor(Math.random() * endings.length)];
      setStorySummary(`제목: ${title}\n요약: ${scenesForSummary.length}장면에 걸쳐 ${cA}와 ${cB}의 이야기가 펼쳐졌다. ${ending}`);
    })();
    const timerPromise = new Promise(r => setTimeout(r, 5000));
    await Promise.all([summaryPromise, timerPromise]);
    setPhase("reborn");
  };
  const reborn = () => {
    setGENRES(buildGenres());
    usedScenes.current = new Set();
    setSeason(s => s + 1); setDay(0); setCtx(""); setLines([]); setAllScenes([]); setBets([]); setMyBets([]);
    setResults([]); setActive([]); setGenre(null); setSetting(null); setSceneArt(null);
    setBetTimer(null); setBetLocked(false); setTimerActive(false); setStorySummary(null); setPhase("genre");
  };

  // Scroll to bottom
  useEffect(() => { if (ref.current) ref.current.scrollTop = ref.current.scrollHeight; }, [lines]);

  // Bet timer countdown
  useEffect(() => {
    if (!timerActive || betTimer === null || betTimer <= 0) return;
    const id = setInterval(() => {
      setBetTimer(prev => {
        if (prev !== null && prev <= 1) {
          clearInterval(id);
          setBetLocked(true);
          setTimerActive(false);
          return 0;
        }
        return prev !== null ? prev - 1 : null;
      });
    }, 1000);
    return () => clearInterval(id);
  }, [timerActive]);

  // Notify when betting locks
  useEffect(() => {
    if (betLocked && betTimer === 0) { notify("베팅 마감!", "error"); if (myBets.length > 0) setTimeout(() => resolve(), 1500); }
  }, [betLocked]);

  // Day 7 season end is now handled by explicit button

  const gc = genre ? GENRES[genre].color : "#888";
  const mono = "'JetBrains Mono',monospace";
  const serif = "'Noto Serif KR',serif";
  const css = `@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@300;400;700;900&family=JetBrains+Mono:wght@400;700&display=swap');
@keyframes fadeUp{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}
@keyframes betSlideIn{from{opacity:0;transform:translateX(20px)}to{opacity:1;transform:translateX(0)}}
@keyframes slideIn{from{opacity:0;transform:translateX(-8px)}to{opacity:1;transform:translateX(0)}}
@keyframes pulse{0%,100%{opacity:.6}50%{opacity:1}}@keyframes blink{0%,100%{opacity:1}50%{opacity:.3}}
@keyframes notifIn{from{opacity:0;transform:translateY(-20px) translateX(-50%)}to{opacity:1;transform:translateY(0) translateX(-50%)}}
@keyframes flicker{0%,100%{opacity:1}96%{opacity:1}97%{opacity:.7}98%{opacity:1}}
@keyframes glitchHard{0%{transform:translate(0);filter:hue-rotate(0)}20%{transform:translate(-4px,2px);filter:hue-rotate(90deg)}40%{transform:translate(2px,-4px);filter:hue-rotate(180deg)}100%{transform:translate(0);filter:hue-rotate(360deg)}}
@keyframes expand{from{letter-spacing:2px;opacity:.5}to{letter-spacing:10px;opacity:1}}@keyframes fadeIn{from{opacity:0}to{opacity:1}}
@keyframes braillePulse{0%,100%{opacity:.04}50%{opacity:.08}}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}::-webkit-scrollbar{width:3px}::-webkit-scrollbar-track{background:#0a0a0a}::-webkit-scrollbar-thumb{background:#222;border-radius:2px}
body{margin:0;overscroll-behavior:none}`;
  const bp = { background: "#0a0a0a", height: "100vh", fontFamily: serif, color: "#e2e2e2", position: "relative", overflow: "hidden" };
  // Apply dvh for mobile browsers
  if (typeof CSS !== "undefined" && CSS.supports && CSS.supports("height", "100dvh")) bp.height = "100dvh";
  const NB = notif && <div style={{ position: "fixed", top: 16, left: "50%", transform: "translateX(-50%)", background: notif.t === "success" ? "#0a1a0a" : notif.t === "error" ? "#1a0a0a" : "#0a0a1a", border: `1px solid ${notif.t === "success" ? "#4ade80" : notif.t === "error" ? "#f87171" : "#60a5fa"}33`, color: notif.t === "success" ? "#4ade80" : notif.t === "error" ? "#f87171" : "#60a5fa", padding: "10px 16px", fontSize: mobile ? 11 : 11, zIndex: 200, fontFamily: mono, animation: "notifIn .3s ease-out", maxWidth: "92vw", textAlign: "left", wordBreak: "break-all", lineHeight: 1.6 }}>{notif.m}</div>;
  const scan = <div style={{ position: "absolute", inset: 0, background: "repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(255,255,255,.015) 2px,rgba(255,255,255,.015) 4px)", pointerEvents: "none", zIndex: 10 }} />;

  // ===== MODAL HELPER =====
  // Modal uses stable ModalOverlay component defined outside

  // ===== INTRO =====
  if (phase === "intro") return (
    <div style={{ ...bp, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", padding: mobile ? 24 : 0 }}>
      <style>{css}</style>{scan}
      <div style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", zIndex: 1, width: "100%", maxWidth: 500 }}>
        <BrailleBlock art={BRAILLE.logo} color="#fff" opacity={0.5} maxW={mobile ? 340 : 480} />
      </div>
      <div style={{ animation: "flicker 8s infinite", textAlign: "center", zIndex: 5, position: "relative" }}>
        <div style={{ fontSize: mobile ? 9 : 11, letterSpacing: mobile ? 4 : 8, color: "#444", marginBottom: 24, fontFamily: mono, textTransform: "uppercase" }}>simulation · betting · reincarnation</div>
        <h1 style={{ fontSize: mobile ? 32 : 48, fontWeight: 900, letterSpacing: -1, margin: "0 0 6px", color: "#fff" }}>An we man we man</h1>
        <div style={{ fontSize: mobile ? 10 : 12, color: "#555", fontFamily: mono, letterSpacing: 3, marginBottom: 40 }}>a̷̢n̵̨w̶̧e̷̢m̵̨ · a̷̢n̵̨w̶̧e̷̢m̵̨</div>
        <div style={{ maxWidth: 340, margin: "0 auto 40px", fontSize: mobile ? 13 : 14, lineHeight: 2, color: "#999", fontWeight: 300 }}>
          AI가 만드는 시뮬레이션 세계.<br />지켜보고, 예측하고, 걸어라.<br />
          <span style={{ color: "#555", fontSize: 11 }}>뮤나는 매번 다른 모습으로 환생한다.</span>
        </div>
        <button onClick={() => setPhase("genre")} style={{ background: "transparent", border: "1px solid #333", color: "#ccc", padding: mobile ? "12px 36px" : "14px 48px", fontSize: 14, fontFamily: serif, cursor: "pointer", letterSpacing: 4, transition: "all .3s" }}>관 전 시 작</button>
      </div>
      <div style={{ position: "absolute", bottom: 20, fontSize: 9, color: "#2a2a2a", fontFamily: mono, letterSpacing: 2, zIndex: 5 }}>mewna의 거울 · 도파민의 세계</div>
    </div>
  );

  // ===== GENRE =====
  if (phase === "genre") return (
    <div style={{ ...bp, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: mobile ? "flex-start" : "center", padding: mobile ? "40px 16px" : 20, overflowY: "auto" }}>
      <style>{css}</style>{NB}
      <div style={{ position: "fixed", bottom: -40, right: -40, zIndex: 0, opacity: 0.43, pointerEvents: "none" }}>
        <BrailleBlock art={BRAILLE.logo} color="#fff" opacity={1} maxW={mobile ? 200 : 300} />
      </div>
      <div style={{ textAlign: "center", zIndex: 5, width: "100%", maxWidth: 720 }}>
        <div style={{ fontSize: 11, letterSpacing: 6, color: "#444", marginBottom: 8, fontFamily: mono }}>SEASON {season}</div>
        <h2 style={{ fontSize: mobile ? 22 : 28, fontWeight: 300, marginBottom: 6 }}>세계를 선택하세요</h2>
        <p style={{ fontSize: mobile ? 13 : 12, color: "#777", marginBottom: 28 }}>뮤나는 이 세계 어딘가에 숨어 있습니다</p>
        <div style={{ display: "flex", gap: 8, justifyContent: "center", flexWrap: "wrap", marginBottom: 28 }}>
          {Object.entries(GENRES).map(([k, g], i) => (
            <div key={k} onClick={() => { setGenre(k); setSetting(null); }} style={{
              width: mobile ? "calc(33% - 6px)" : 115, padding: mobile ? "14px 6px" : "22px 10px",
              border: `1px solid ${genre === k ? g.color + "88" : "#1a1a1a"}`,
              background: genre === k ? g.color + "0a" : "#0c0c0c", cursor: "pointer", textAlign: "center",
              transition: "all .3s", animation: `fadeUp .5s ease-out ${i * .06}s both`,
            }}>
              <pre style={{ fontFamily: "'JetBrains Mono',monospace", fontSize: mobile ? 8 : 9, lineHeight: 1.1, color: genre === k ? g.color : "#444", margin: "0 0 4px", textAlign: "center" }}>{ART.genre[k]}</pre>
              <div style={{ fontSize: mobile ? 14 : 13, color: genre === k ? g.color : "#aaa", fontWeight: genre === k ? 700 : 400 }}>{g.name}</div>
              <div style={{ fontSize: mobile ? 11 : 10, color: "#555", marginTop: 4, lineHeight: 1.4 }}>{g.desc}</div>
            </div>
          ))}
        </div>
        {genre && <div style={{ animation: "fadeUp .4s ease-out" }}>
          <p style={{ fontSize: 11, color: "#555", marginBottom: 12 }}>시나리오</p>
          <div style={{ display: "flex", gap: 8, justifyContent: "center", flexWrap: "wrap", marginBottom: 28 }}>
            {GENRES[genre].settings.map((s, i) => (
              <div key={i} onClick={() => { setSetting(s); setMewna(GENRES[genre].mewnaForms[Math.floor(Math.random() * GENRES[genre].mewnaForms.length)]); }} style={{
                width: mobile ? "100%" : 240, padding: mobile ? 14 : 18, textAlign: "left",
                border: `1px solid ${setting === s ? GENRES[genre].color + "66" : "#1a1a1a"}`,
                background: setting === s ? GENRES[genre].color + "08" : "#0c0c0c", cursor: "pointer",
              }}>
                <div style={{ fontSize: mobile ? 15 : 14, color: setting === s ? GENRES[genre].color : "#ccc", fontWeight: 700, marginBottom: 4 }}>{s.title}</div>
                <div style={{ fontSize: mobile ? 13 : 12, color: "#666", lineHeight: 1.5 }}>{s.desc}</div>
                <div style={{ marginTop: 6, display: "flex", gap: 4 }}>
                  {s.characters.map(c => <span key={c.id} style={{ fontSize: mobile ? 11 : 10, color: "#555", fontFamily: mono, background: "#111", padding: "2px 8px" }}>{c.name} {c.gender}</span>)}
                </div>
              </div>
            ))}
          </div>
        </div>}
        {setting && <button onClick={() => setPhase("playing")} style={{
          background: "transparent", border: `1px solid ${GENRES[genre].color}44`, color: GENRES[genre].color,
          padding: "12px 40px", fontSize: 13, fontFamily: serif, cursor: "pointer", letterSpacing: 3,
          animation: "fadeUp .5s ease-out", marginBottom: 40,
        }}>시 뮬 레 이 션 시 작</button>}
      </div>
    </div>
  );

  // ===== DEATH =====
  if (phase === "death") return (
    <div style={{ ...bp, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", padding: 24 }}>
      <style>{css}</style>
      <div style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", zIndex: 1, width: "100%", maxWidth: 500, animation: "glitchHard .5s infinite" }}>
        <BrailleBlock art={BRAILLE.logo} color="#f87171" opacity={0.53} maxW={mobile ? 340 : 480} />
      </div>
      <div style={{ textAlign: "center", zIndex: 5, position: "relative" }}>
        <div style={{ fontSize: 14, color: "#f87171", marginBottom: 16, fontFamily: mono }}>SEASON {season} — COLLAPSE</div>
        <div style={{ fontSize: mobile ? 28 : 38, fontWeight: 900, marginBottom: 24 }}><GlitchText text="An we man we man" intensity={3} /></div>
        <div style={{ fontSize: 12, color: "#555", lineHeight: 2.5, fontFamily: mono, animation: "expand 2s ease-out forwards" }}>
          An we man we man we man<br /><span style={{ color: "#f87171" }}>An we man we man we man we man</span>
        </div>
      </div>
    </div>
  );

  // ===== REBORN =====
  if (phase === "gameover") return (
    <div style={{ ...bp, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", textAlign: "center", padding: 24 }}>
      <style>{css}</style>
      <div style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", zIndex: 1, width: "100%", maxWidth: 500, opacity: 0.3 }}>
        <BrailleBlock art={BRAILLE.logo} color="#f87171" opacity={0.6} maxW={mobile ? 340 : 480} />
      </div>
      <div style={{ zIndex: 5, position: "relative", animation: "fadeIn 1s ease-out" }}>
        <div style={{ fontSize: 11, color: "#f87171", fontFamily: mono, letterSpacing: 4, marginBottom: 20 }}>GAME OVER</div>
        <div style={{ fontSize: mobile ? 24 : 32, fontWeight: 900, color: "#f87171", marginBottom: 12 }}>
          <GlitchText text="업이 소진되었습니다" intensity={1} />
        </div>
        <div style={{ fontSize: mobile ? 14 : 13, color: "#555", lineHeight: 2, marginBottom: 8 }}>
          시즌 {season} · 장면 {day}/{SEASON_LEN}
        </div>
        <div style={{ fontSize: mobile ? 13 : 12, color: "#444", lineHeight: 1.8, marginBottom: 30, maxWidth: 300, margin: "0 auto 30px" }}>
          뮤나의 환생은 끊기지 않는다.<br />다시 1000업으로 시작합니다.
        </div>
        <button onClick={() => {
          setGENRES(buildGenres());
          setKarma(1000); setSeason(1); setDay(0); setCtx(""); setLines([]); setAllScenes([]); setBets([]); setMyBets([]);
          setResults([]); setActive([]); setInv([]); setGenre(null); setSetting(null); setSceneArt(null);
          setBetTimer(null); setBetLocked(false); setTimerActive(false); setStorySummary(null); setPhase("genre");
        }} style={{
          background: "transparent", border: "1px solid #f8717144", color: "#f87171",
          padding: "14px 40px", fontSize: 14, fontFamily: serif, cursor: "pointer", letterSpacing: 3,
        }}>
          처 음 부 터
        </button>
      </div>
    </div>
  );

  if (phase === "reborn") return (
    <div style={{ ...bp, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", textAlign: "center", padding: 24 }}>
      <style>{css}</style>
      <div style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -55%)", zIndex: 1, width: "100%", maxWidth: 400 }}>
        <BrailleBlock art={BRAILLE.tpose} color="#fff" opacity={0.5} maxW={mobile ? 300 : 380} glow />
      </div>
      <div style={{ animation: "fadeIn 2s ease-out", zIndex: 5, position: "relative", maxWidth: 400, width: "100%" }}>
        <div style={{ fontSize: 11, color: "#444", letterSpacing: 6, fontFamily: mono, marginBottom: 24 }}>REINCARNATION</div>
        <div style={{ fontSize: mobile ? 24 : 30, fontWeight: 300, marginBottom: 8 }}>시즌 {season} 종료</div>
        <div style={{ fontSize: 13, color: "#777", marginBottom: 6 }}>{SEASON_LEN}장면 완료 · 업 {karma}</div>
        {storySummary && (() => {
          const titleMatch = storySummary.match(/제목[:：]\s*(.+)/);
          const summaryMatch = storySummary.match(/요약[:：]\s*([\s\S]+)/);
          const title = titleMatch ? titleMatch[1].trim() : null;
          const summary = summaryMatch ? summaryMatch[1].trim() : storySummary;
          return (
            <div style={{ margin: "20px auto", padding: "16px 20px", background: "#0a0a0a", border: `1px solid ${gc}22`, maxWidth: 360, textAlign: "left", animation: "fadeIn 1.5s ease-out" }}>
              {title && <div style={{ fontSize: mobile ? 15 : 14, color: gc, fontWeight: 700, marginBottom: 10, textAlign: "center", fontFamily: serif }}>「{title}」</div>}
              <div style={{ fontSize: mobile ? 13 : 12, color: "#999", lineHeight: 2, fontFamily: serif }}>{summary}</div>
              <div style={{ fontSize: 9, color: "#333", fontFamily: mono, marginTop: 10, textAlign: "right" }}>— {GENRES[genre]?.name || "???"} · {setting?.characters?.map(c => c.name).join(" & ")}</div>
            </div>
          );
        })()}
        <div style={{ fontSize: 11, color: "#444", marginBottom: 30, lineHeight: 1.8 }}>새로운 세계가 열립니다.<br />뮤나는 다시 어딘가에...</div>
        <button onClick={reborn} style={{ background: "transparent", border: "1px solid #333", color: "#ccc", padding: "12px 40px", fontSize: 13, fontFamily: serif, cursor: "pointer", letterSpacing: 4 }}>다 음 세 계</button>
      </div>
    </div>
  );

  // ===== PLAYING =====
  const StoryPanel = () => (
    <div style={{ flex: 1, display: "flex", flexDirection: "column", minHeight: 0 }}>
      {/* Characters */}
      <div style={{ display: "flex", justifyContent: "center", gap: mobile ? 30 : 44, padding: mobile ? "14px 12px 6px" : "20px 16px 10px", background: "#0c0c0c" }}>
        {setting?.characters.map(c => (
          <div key={c.id} style={{ textAlign: "center" }}>
            <pre style={{ fontFamily: "'JetBrains Mono',monospace", fontSize: mobile ? 9 : 10, lineHeight: 1.1, color: (c.gender === "♂" ? "#60a5fa" : c.gender === "♀" ? "#e8a0b4" : "#c4a0e8") + "66", margin: "0 auto 4px", textAlign: "center" }}>{c.id === "A" ? ART.charA : ART.charB}</pre>
            <div style={{ fontSize: mobile ? 17 : 15, color: c.gender === "♂" ? "#60a5fa" : c.gender === "♀" ? "#e8a0b4" : "#c4a0e8", fontWeight: 700 }}>{c.name}</div>
            <div style={{ fontSize: mobile ? 9 : 8, color: "#444", fontFamily: mono, marginTop: 1 }}>{c.age > 0 ? c.age : "?"} · {c.gender}</div>
          </div>
        ))}
      </div>
      <div style={{ textAlign: "center", padding: "2px 0", borderBottom: "1px solid #131313" }}>
        <span style={{ fontSize: 8, color: "#1a1a1a", fontFamily: mono, letterSpacing: 4 }}>{ART.divider}</span>
      </div>
      {/* Inventory */}
      {inv.length > 0 && (
        <div style={{ display: "flex", gap: 4, padding: "5px 12px", borderBottom: "1px solid #131313", flexWrap: "wrap" }}>
          {inv.map((id, i) => { const it = SHOP_ITEMS.find(x => x.id === id); return (
            <button key={i} onClick={() => use(id)} style={{ background: "#0a0a0a", border: `1px solid ${RC[it?.rarity]}33`, color: RC[it?.rarity], padding: mobile ? "5px 10px" : "3px 8px", fontSize: mobile ? 11 : 10, cursor: "pointer", fontFamily: mono }}>{it?.icon} {it?.name}</button>
          ); })}
        </div>
      )}
      {/* Scene */}
      <div ref={ref} style={{ flex: 1, overflowY: "auto", WebkitOverflowScrolling: "touch", height: 0, padding: mobile ? "12px 16px" : "14px 22px", display: "flex", flexDirection: "column", gap: 1 }}>
        {day === 0 && !genning && (
          <div style={{ textAlign: "center", marginTop: 10 }}>
            <div style={{ maxWidth: mobile ? 260 : 300, margin: "0 auto", opacity: 0.8 }}>
              <BrailleBlock art={BRAILLE.tpose} color={gc} opacity={0.55} maxW={mobile ? 220 : 280} />
            </div>
            <div style={{ color: "#555", fontSize: mobile ? 20 : 17, lineHeight: 2, marginTop: 8 }}>
              {setting?.title}<br /><span style={{ fontSize: mobile ? 16 : 14, color: "#444" }}>{setting?.desc}</span><br /><br />
              <span style={{ color: "#444", fontSize: mobile ? 16 : 14 }}>뮤나가 어딘가에 있습니다...</span>
            </div>
          </div>
        )}
        {genning && (
          <div style={{ textAlign: "center", marginTop: mobile ? 60 : 80 }}>
            <div style={{ color: "#333", fontSize: mobile ? 14 : 13, animation: "pulse 3s infinite", letterSpacing: 2, fontFamily: mono }}>
              장면 생성 중...
            </div>
          </div>
        )}
        {sceneArt && day > 0 && (
          <div style={{ textAlign: "center", margin: "6px 0 10px", animation: "fadeUp .6s ease-out" }}>
            <ArtBlock art={sceneArt} color={gc + "44"} size={mobile ? 7 : 8} />
            <div style={{ fontSize: 8, color: "#1a1a1a", fontFamily: mono, marginTop: 2, letterSpacing: 4 }}>{ART.divider}</div>
          </div>
        )}
        {/* Previous scenes (accumulated) */}
        {allScenes.map((sc, si) => {
          const genreKey = genre ? Object.entries(GENRE_BASE).find(([k, v]) => v.name === GENRES[genre]?.name)?.[0] : null;
          const stageName = genreKey && GENRE_STAGES[genreKey]?.stages[sc.sceneNum]?.name || "";
          return (
          <div key={`sc-${si}`} style={{ opacity: 0.45, marginBottom: 8 }}>
            {/* Scene divider */}
            <div style={{ textAlign: "center", padding: "10px 0 6px", display: "flex", alignItems: "center", gap: 8, justifyContent: "center" }}>
              <div style={{ flex: 1, height: 1, background: "#1a1a1a" }} />
              <span style={{ fontSize: 9, color: "#444", fontFamily: mono, letterSpacing: 2, whiteSpace: "nowrap" }}>장면 {sc.sceneNum} · {stageName}</span>
              <div style={{ flex: 1, height: 1, background: "#1a1a1a" }} />
            </div>
            {sc.lines.map((l, li) => (
              <div key={li} style={{ padding: "3px 0" }}>
                {l.s === "n" ? <div style={{ color: "#7090a8", fontSize: mobile ? 14 : 13, fontStyle: "italic", textAlign: "center", padding: "2px 0" }}>{l.t}</div> : (
                  <div style={{ display: "flex", gap: 8, alignItems: "flex-start" }}>
                    <span style={{ color: charColor(l.s, setting), fontSize: mobile ? 14 : 13, fontWeight: 700, minWidth: 28, fontFamily: mono }}>{setting?.characters.find(c => c.id === l.s)?.name || (l.s === "C" ? "C" : "?")}</span>
                    <span style={{ color: "#ccc", fontSize: mobile ? 16 : 14, lineHeight: 1.6, fontWeight: 500 }}>{l.t}</span>
                  </div>
                )}
              </div>
            ))}
            {sc.outcome && <div style={{ textAlign: "center", padding: "4px 0 2px", fontSize: 10, color: "#60a5fa88", fontFamily: mono }}>→ {sc.outcome}</div>}
          </div>
          );
        })}
        {/* Current scene divider */}
        {day > 0 && lines.length > 0 && (
          <div style={{ textAlign: "center", padding: "10px 0 6px", display: "flex", alignItems: "center", gap: 8, justifyContent: "center" }}>
            <div style={{ flex: 1, height: 1, background: gc + "33" }} />
            <span style={{ fontSize: 10, color: gc, fontFamily: mono, letterSpacing: 2, whiteSpace: "nowrap" }}>장면 {day}{(() => { const gk = genre ? Object.entries(GENRE_BASE).find(([k, v]) => v.name === GENRES[genre]?.name)?.[0] : null; const sn = gk && GENRE_STAGES[gk]?.stages[day]?.name; return sn ? ` · ${sn}` : ""; })()}</span>
            <div style={{ flex: 1, height: 1, background: gc + "33" }} />
          </div>
        )}
        {/* Current scene lines */}
        {lines.map((l, i) => (
          <div key={i} style={{ padding: "5px 0", ...(i === lines.length - 1 ? { animation: "fadeIn .4s ease-out" } : {}) }}>
            {l.s === "n" ? <div style={{ color: "#7090a8", fontSize: mobile ? 17 : 16, fontStyle: "italic", textAlign: "center", padding: "4px 0" }}>{
              l.t.split(/(\([^)]+\))/).map((part, pi) =>
                part.startsWith("(") && part.endsWith(")") ?
                  <span key={pi} style={{ color: "#a78bfa", fontWeight: 400 }}>{part}</span> :
                  <span key={pi}>{part}</span>
              )
            }</div> : (
              <div style={{ display: "flex", gap: 8, alignItems: "flex-start" }}>
                <span style={{ color: charColor(l.s, setting), fontSize: mobile ? 17 : 15, fontWeight: 700, minWidth: 28, fontFamily: mono }}>{setting?.characters.find(c => c.id === l.s)?.name || (l.s === "C" ? "C" : "?")}</span>
                <span style={{ color: "#fff", fontSize: mobile ? 20 : 18, lineHeight: 1.8, fontWeight: 700 }}>{
                  l.t.split(/(\([^)]+\))/).map((part, pi) =>
                    part.startsWith("(") && part.endsWith(")") ?
                      <span key={pi} style={{ color: "#a78bfa", fontStyle: "italic", fontWeight: 300, fontSize: mobile ? 16 : 14 }}>{part}</span> :
                      <span key={pi}>{part}</span>
                  )
                }</span>
              </div>
            )}
          </div>
        ))}
        {revealing && <div style={{ color: "#333", fontSize: 11, padding: "5px 0", animation: "pulse 1.5s infinite" }}>▍</div>}
        {results.length > 0 && (
          <div style={{ margin: "12px 0", padding: mobile ? 14 : 12, border: "1px solid #60a5fa33", background: "#0a0a14", animation: "fadeIn .4s ease-out" }}>
            <div style={{ fontSize: mobile ? 12 : 11, color: "#60a5fa", fontFamily: mono, marginBottom: 8, letterSpacing: 2 }}>⬢ RESULT</div>
            {correctBet && <div style={{ fontSize: mobile ? 16 : 14, color: "#60a5fa", padding: "6px 0 10px", borderBottom: "1px solid #60a5fa22", marginBottom: 8 }}>
              <span style={{ color: "#60a5fa88", fontFamily: mono, fontSize: mobile ? 11 : 10, marginRight: 8 }}>정답</span>
              <span style={{ fontWeight: 700 }}>{correctBet.text}</span>
              <span style={{ color: "#60a5fa88", fontFamily: mono, fontSize: mobile ? 11 : 10, marginLeft: 8 }}>×{correctBet.odds.toFixed(1)}</span>
            </div>}
            {results.map((r, i) => (
              <div key={i} style={{ display: "flex", justifyContent: "space-between", padding: "5px 0", fontSize: mobile ? 17 : 15, color: r.won ? "#4ade80" : "#f87171" }}>
                <span style={{ fontWeight: r.won ? 700 : 400 }}>{r.won ? "✓ " : "✗ "}{r.text}</span>
                <span style={{ fontFamily: mono, fontWeight: 700 }}>{r.won ? `+${r.pay}` : r.insured && r.pay > 0 ? `−${r.amount - r.pay} (보험)` : `−${r.amount}`}</span>
              </div>
            ))}
          </div>
        )}
      </div>
      {/* Action */}
      <div className="safe-bottom" style={{ padding: mobile ? "8px 12px" : "10px 14px", borderTop: "1px solid #131313", display: "flex", gap: 6 }}>
        {day < SEASON_LEN ? (
          results.length > 0 ? (
            <button onClick={() => { setTimerActive(false); setBetTimer(null); setBetLocked(false); genScene(); }}
              style={{ flex: 1, background: "#0a1a0a", border: "1px solid #4ade8033", color: "#4ade80", padding: mobile ? "14px 0" : "10px 0", fontSize: mobile ? 15 : 14, fontFamily: serif, cursor: "pointer", letterSpacing: 2 }}>
              ▶  결과 확인 → 다음 장면
            </button>
          ) : (
          <button onClick={() => {
            if (myBets.length) { resolve(); return; }
            setTimerActive(false); setBetTimer(null); setBetLocked(false); genScene();
          }} disabled={genning || revealing}
            style={{ flex: 1, background: genning ? "#0c0c0c" : day === SEASON_LEN - 1 ? "#1a0a0a" : "#111", border: `1px solid ${genning ? "#151515" : day === SEASON_LEN - 1 ? "#f8717133" : "#222"}`, color: genning ? "#333" : day === SEASON_LEN - 1 ? "#f87171" : "#aaa", padding: mobile ? "14px 0" : "10px 0", fontSize: mobile ? 15 : 14, fontFamily: serif, cursor: genning ? "not-allowed" : "pointer", letterSpacing: 2 }}>
            {genning ? "생성 중..." : day === 0 ? "▶  첫 장면" : myBets.length > 0 ? "⬢  베팅 결과 확인" : day === SEASON_LEN - 1 ? "☠  마지막 장면" : `▶  다음 장면 (${day}/${SEASON_LEN})`}
          </button>
          )
        ) : (
          results.length > 0 ? (
            <button onClick={() => { setResults([]); setCorrectBet(null); die(); }}
              style={{ flex: 1, background: "#1a0a0a", border: "1px solid #f8717133", color: "#f87171", padding: mobile ? "14px 0" : "10px 0", fontSize: mobile ? 15 : 14, fontFamily: serif, cursor: "pointer", letterSpacing: 2 }}>
              ☠  결과 확인 → 시즌 종료
            </button>
          ) : myBets.length > 0 ? (
            <button onClick={() => resolve()}
              style={{ flex: 1, background: "#1a1a0a", border: "1px solid #f59e0b33", color: "#f59e0b", padding: mobile ? "14px 0" : "10px 0", fontSize: mobile ? 15 : 14, fontFamily: serif, cursor: "pointer", letterSpacing: 2 }}>
              ⬢  마지막 베팅 결과 확인
            </button>
          ) : (
            <button onClick={() => die()}
              style={{ flex: 1, background: "#1a0a0a", border: "1px solid #f8717133", color: "#f87171", padding: mobile ? "14px 0" : "10px 0", fontSize: mobile ? 15 : 14, fontFamily: serif, cursor: "pointer", letterSpacing: 2, animation: "pulse 2s infinite" }}>
              ☠  시 즌  종 료
            </button>
          )
        )}
      </div>
    </div>
  );

  const BetPanel = () => {
    const timerPct = betTimer !== null ? (betTimer / 120) * 100 : 0;
    const timerColor = betTimer !== null && betTimer <= 30 ? "#f87171" : betTimer !== null && betTimer <= 60 ? "#f59e0b" : "#4ade80";
    const timerMin = betTimer !== null ? Math.floor(betTimer / 60) : 0;
    const timerSec = betTimer !== null ? betTimer % 60 : 0;
    const isChoiceMode = bets.length > 0 && bets[0]?.isChoice;
    // Get current stage info
    const genreKey = genre ? Object.entries(GENRE_BASE).find(([k, v]) => v.name === GENRES[genre]?.name)?.[0] : null;
    const stageInfo = genreKey && GENRE_STAGES[genreKey]?.stages[day];
    return (
    <div style={{ display: "flex", flexDirection: "column", flex: mobile ? 1 : undefined, width: mobile ? "100%" : 290, background: "#0b0b0b", minHeight: 0 }}>
      {!mobile && <div style={{ padding: "10px 12px", borderBottom: "1px solid #131313", fontFamily: mono, fontSize: 9, color: "#444", letterSpacing: 3 }}>
        {isChoiceMode ? <span style={{ color: "#f59e0b" }}>⑆ 운명의 선택지</span> : "BETTING"}
      </div>}
      {/* Stage indicator */}
      {stageInfo && day > 0 && (
        <div style={{ padding: "4px 12px", borderBottom: "1px solid #0f0f0f", display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <span style={{ fontSize: 9, color: "#555", fontFamily: mono }}>{day}/7 "{stageInfo.name}"</span>
          <span style={{ fontSize: 8, color: "#333", fontFamily: mono }}>베팅 {stageInfo.betN}개</span>
        </div>
      )}
      {/* Timer bar */}
      {betTimer !== null && betTimer > 0 && !isChoiceMode && (
        <div style={{ padding: "8px 12px", borderBottom: "1px solid #131313" }}>
          <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 4 }}>
            <span style={{ fontSize: mobile ? 11 : 9, color: timerColor, fontFamily: mono, fontWeight: 700 }}>
              {betLocked ? "CLOSED" : `${timerMin}:${timerSec.toString().padStart(2, "0")}`}
            </span>
            <span style={{ fontSize: 8, color: "#444", fontFamily: mono }}>베팅 마감까지</span>
          </div>
          <div style={{ width: "100%", height: 3, background: "#1a1a1a", borderRadius: 2, overflow: "hidden" }}>
            <div style={{ width: `${timerPct}%`, height: "100%", background: timerColor, transition: "width 1s linear, background .3s", borderRadius: 2 }} />
          </div>
        </div>
      )}
      {betLocked && betTimer === 0 && !isChoiceMode && (
        <div style={{ padding: "8px 12px", borderBottom: "1px solid #131313", textAlign: "center" }}>
          <span style={{ fontSize: mobile ? 12 : 10, color: "#f87171", fontFamily: mono, fontWeight: 700, animation: "pulse 1.5s infinite" }}>⊘ 베팅 마감</span>
        </div>
      )}
      {/* Choice mode: no bet amount selector */}
      {isChoiceMode ? (
        <div style={{ padding: "8px 12px", borderBottom: "1px solid #131313", textAlign: "center" }}>
          <span style={{ fontSize: mobile ? 12 : 10, color: "#f59e0b", fontFamily: mono }}>⑆ 스토리의 방향을 선택하세요</span>
        </div>
      ) : (
        <div style={{ padding: "8px 12px", borderBottom: "1px solid #131313", display: "flex", alignItems: "center", gap: 5 }}>
          <span style={{ fontSize: mobile ? 11 : 10, color: "#555", fontFamily: mono }}>베팅액</span>
          {[50, 100, 200, 500].map(a => (
            <button key={a} onClick={() => karma >= a && setBetAmt(a)} style={{ background: betAmt === a ? "#1a1a0a" : "#0c0c0c", border: `1px solid ${betAmt === a ? "#f59e0b33" : "#151515"}`, color: karma < a ? "#222" : betAmt === a ? "#f59e0b" : "#444", padding: mobile ? "6px 12px" : "3px 8px", fontSize: mobile ? 13 : 10, cursor: karma < a ? "not-allowed" : "pointer", fontFamily: mono, opacity: karma < a ? 0.4 : 1, textDecoration: karma < a ? "line-through" : "none" }}>{a}</button>
          ))}
        </div>
      )}
      <div style={{ flex: 1, overflowY: "auto", WebkitOverflowScrolling: "touch", height: 0, padding: "4px 0" }}>
        {bets.length === 0 && !betsLoading && <div style={{ textAlign: "center", marginTop: 20, padding: "0 14px" }}>
              <ArtBlock art={ART.bet} color="#252525" size={mobile ? 10 : 9} />
              <div style={{ color: "#333", fontSize: mobile ? 18 : 15, marginTop: 8, lineHeight: 1.8 }}>장면이 나오면<br />베팅이 열립니다</div>
            </div>}
        {betsLoading && bets.length === 0 && <div style={{ textAlign: "center", marginTop: 20, padding: "0 14px" }}>
              <div style={{ color: "#4ade80", fontSize: mobile ? 14 : 12, fontFamily: mono, animation: "pulse 1.5s ease-in-out infinite" }}>⟳ 베팅 생성 중...</div>
              <div style={{ color: "#333", fontSize: mobile ? 11 : 9, marginTop: 6, fontFamily: mono }}>스토리를 읽으면서 기다려주세요</div>
            </div>}
        {bets.slice(0, betsRevealed).map((b, idx) => {
          const p = myBets.find(x => x.id === b.id);
          return (
            <div key={b.id} onClick={() => !(betLocked && !b.isChoice) && placeBet(b)} style={{
              margin: "3px 8px", padding: mobile ? "12px" : "10px",
              background: b.isChoice ? (p ? "#1a1a0a" : "#0f0a00") : p ? "#0a1a0a" : betLocked ? "#0a0a0a" : "#0c0c0c",
              border: `1px solid ${b.isChoice ? "#f59e0b33" : p ? "#4ade8033" : "#131313"}`,
              cursor: betLocked && !b.isChoice ? "default" : "pointer",
              opacity: betLocked && !p && !b.isChoice ? 0.5 : 1,
              animation: "betSlideIn 0.4s ease-out",
              animationFillMode: "backwards",
              animationDelay: `${idx * 0.05}s`,
            }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                <span style={{ fontSize: mobile ? 18 : 15, color: b.isChoice ? "#f59e0b" : p ? "#4ade80" : betLocked ? "#666" : "#bbb", flex: 1, lineHeight: 1.5 }}>
                  {b.isChoice && "⑆ "}{b.text}
                </span>
                <div style={{ textAlign: "right", marginLeft: 8 }}>
                  {b.isChoice ? (
                    <span style={{ color: "#f59e0b", fontFamily: mono, fontSize: 11 }}>선택</span>
                  ) : (
                    <>
                      <OddsTicker baseOdds={b.odds} active={!p && !betLocked && day > 0} />
                      {p && <div style={{ fontSize: mobile ? 10 : 9, color: "#4ade80", marginTop: 2, fontFamily: mono }}>{p.amount}업 <span style={{ color: "#4ade8066", fontSize: mobile ? 9 : 8 }}>탭→취소</span></div>}
                    </>
                  )}
                </div>
              </div>
            </div>
          );
        })}
      </div>
      {myBets.length > 0 && !isChoiceMode && (
        <div style={{ padding: "8px 12px", borderTop: "1px solid #131313", background: "#0a0f0a" }}>
          <div style={{ fontSize: mobile ? 11 : 10, color: "#4ade80", fontFamily: mono, display: "flex", justifyContent: "space-between" }}>
            <span>베팅 {myBets.length}건</span><span>{myBets.reduce((s, b) => s + b.amount, 0)}업</span>
          </div>
        </div>
      )}
      <div className="safe-bottom" style={{ padding: "10px 12px", borderTop: "1px solid #131313", display: "flex", justifyContent: "space-between", alignItems: "center" }}>
        <div>
          <div style={{ fontSize: mobile ? 10 : 9, color: "#444", fontFamily: mono, letterSpacing: 2 }}>KARMA</div>
          <div style={{ fontSize: mobile ? 22 : 18, color: "#f59e0b", fontFamily: mono, fontWeight: 700 }}>{karma.toLocaleString()}</div>
        </div>
        <div style={{ fontSize: 8, color: "#262626", fontFamily: mono }}>S{season} #{day}/{SEASON_LEN}</div>
      </div>
    </div>
  );};

  return (
    <div style={{ ...bp, display: "flex", flexDirection: "column" }}>
      <style>{css}</style>{NB}

      {/* Modals */}
      {cardModal && <ModalOverlay mobile={mobile} onClose={() => setCardModal(null)}>
        <div style={{ textAlign: "center" }}>
          <div style={{ fontSize: 10, color: gc, fontFamily: mono, letterSpacing: 3, marginBottom: 4 }}>SCREENSHOT CARD</div>
          <div style={{ fontSize: 8, color: "#444", fontFamily: mono, marginBottom: 14 }}>S{season} · #{day} · {GENRES[genre]?.name}</div>
          <div style={{ background: "#0a0a0a", border: "1px solid #1a1a1a", padding: 14, marginBottom: 14, textAlign: "left" }}>
            {cardModal.map((l, i) => (
              <div key={i} style={{ fontSize: 12, color: l.s === "n" ? "#555" : "#bbb", fontStyle: l.s === "n" ? "italic" : "normal", marginBottom: 3 }}>
                {l.s !== "n" && <span style={{ color: charColor(l.s, setting), fontWeight: 700, fontFamily: mono, fontSize: 10, marginRight: 4 }}>{setting?.characters.find(c => c.id === l.s)?.name || (l.s === "C" ? "C" : "?")}</span>}{l.t}
              </div>
            ))}
          </div>
          <div style={{ fontSize: 8, color: "#333", fontFamily: mono }}>An we man we man</div>
          <ArtBlock art={ART.divider} color="#1a1a1a" size={7} />
        </div>
      </ModalOverlay>}

      {peekModal && <ModalOverlay mobile={mobile} onClose={() => setPeekModal(null)}>
        <div style={{ textAlign: "center" }}>
          <div style={{ fontSize: 10, color: "#a78bfa", fontFamily: mono, letterSpacing: 3, marginBottom: 4 }}>◈ PEEK — 비밀 엿보기</div>
          <div style={{ fontSize: 8, color: "#444", fontFamily: mono, marginBottom: 14 }}>S{season} · #{day}</div>
          <div style={{ textAlign: "left" }}>
            {peekModal.map((c, i) => (
              <div key={i} style={{ background: "#0a0a0a", border: "1px solid #a78bfa11", padding: "12px 14px", marginBottom: 8, animation: `fadeIn ${0.5 + i * 0.3}s ease-out` }}>
                <div style={{ fontSize: mobile ? 14 : 13, color: c.gender === "♂" ? "#60a5fa" : c.gender === "♀" ? "#e8a0b4" : "#c4a0e8", fontWeight: 700, marginBottom: 6, fontFamily: mono }}>{c.name} <span style={{ fontSize: 10, color: "#555", fontWeight: 400 }}>{c.gender}</span></div>
                <div style={{ fontSize: mobile ? 13 : 12, color: "#a78bfa", lineHeight: 1.8, fontFamily: serif }}>"{c.secret}"</div>
              </div>
            ))}
          </div>
        </div>
      </ModalOverlay>}

      {whisperOpen && <ModalOverlay mobile={mobile} onClose={() => { setWhisperOpen(false); setInv(p => [...p, "whisper"]); }}>
        <div style={{ textAlign: "center" }}>
          <div style={{ fontSize: 12, color: "#f59e0b", marginBottom: 8, fontFamily: mono }}>속삭임</div>
          <div style={{ fontSize: 11, color: "#666", marginBottom: 12 }}>캐릭터에게 전할 메시지</div>
          <input value={whisper} onChange={e => setWhisper(e.target.value)} placeholder="예: 솔직해져..."
            autoFocus
            style={{ width: "100%", background: "#0a0a0a", border: "1px solid #222", color: "#ccc", padding: "10px 12px", fontSize: 13, fontFamily: serif, marginBottom: 12, boxSizing: "border-box" }} />
          <div style={{ display: "flex", gap: 8, justifyContent: "center" }}>
            <button onClick={() => { setWhisperOpen(false); notify("속삭임 전달...", "success"); }}
              style={{ background: "#1a1a0a", border: "1px solid #f59e0b44", color: "#f59e0b", padding: "8px 24px", fontSize: 12, cursor: "pointer", fontFamily: mono }}>전달</button>
            <button onClick={() => { setWhisperOpen(false); setWhisper(""); setInv(p => [...p, "whisper"]); }}
              style={{ background: "#111", border: "1px solid #222", color: "#666", padding: "8px 24px", fontSize: 12, cursor: "pointer", fontFamily: mono }}>취소</button>
          </div>
        </div>
      </ModalOverlay>}

      {shop && <ModalOverlay mobile={mobile} onClose={() => setShop(false)}>
        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 14 }}>
          <div style={{ fontSize: 11, color: "#555", fontFamily: mono, letterSpacing: 3 }}>업 SHOP</div>
          <button onClick={() => setShop(false)} style={{ background: "none", border: "none", color: "#555", cursor: "pointer", fontSize: 16 }}>✕</button>
        </div>
        <div style={{ fontSize: 10, color: "#f59e0b", fontFamily: mono, marginBottom: 12 }}>보유: {karma}</div>
        {["개입", "정보", "베팅", "수집"].map(cat => (
          <div key={cat} style={{ marginBottom: 12 }}>
            <div style={{ fontSize: 9, color: "#444", fontFamily: mono, letterSpacing: 2, marginBottom: 5 }}>{cat}</div>
            {SHOP_ITEMS.filter(i => i.cat === cat).map(item => (
              <div key={item.id} style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "8px 8px", marginBottom: 2, background: "#111", border: "1px solid #151515" }}>
                <div style={{ flex: 1 }}>
                  <span style={{ color: RC[item.rarity], fontSize: 12, fontWeight: 700 }}>{item.icon} {item.name}</span>
                  <div style={{ fontSize: 10, color: "#555", marginTop: 1 }}>{item.desc}</div>
                </div>
                <button onClick={() => buy(item)} style={{
                  background: karma >= item.price ? "#1a1a0a" : "#111", border: `1px solid ${karma >= item.price ? "#f59e0b33" : "#151515"}`,
                  color: karma >= item.price ? "#f59e0b" : "#333", padding: "4px 12px", fontSize: 11,
                  cursor: karma >= item.price ? "pointer" : "not-allowed", fontFamily: mono,
                }}>{item.price}</button>
              </div>
            ))}
          </div>
        ))}
      </ModalOverlay>}

      {/* API Settings Modal */}
      {showApiCfg && <ModalOverlay mobile={mobile} onClose={() => setShowApiCfg(false)}>
        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 16 }}>
          <span style={{ color: "#888", fontFamily: mono, fontSize: 13 }}>⚙ AI 엔진 설정</span>
          <button onClick={() => setShowApiCfg(false)} style={{ background: "none", border: "none", color: "#555", cursor: "pointer", fontSize: 16 }}>✕</button>
        </div>
        <div style={{ color: "#555", fontSize: 11, marginBottom: 12, lineHeight: 1.6 }}>
          AI로 장면을 생성합니다. API 키만 넣으면 끝.
        </div>
        {/* Provider buttons */}
        <div style={{ display: "flex", flexWrap: "wrap", gap: 6, marginBottom: 14 }}>
          {Object.entries(API_PRESETS).map(([k, v]) => (
            <button key={k} onClick={() => {
              const preset = API_PRESETS[k];
              const recModel = preset.models?.find(m => m.rec)?.id || preset.models?.[0]?.id || "";
              setApiCfg(prev => ({ provider: k, key: k === "off" ? "" : prev.key, model: recModel, endpoint: preset.endpoint || prev.endpoint }));
            }} style={{
              background: apiCfg.provider === k ? "#1a2a1a" : "#111",
              border: `1px solid ${apiCfg.provider === k ? "#2a6" : "#222"}`,
              color: apiCfg.provider === k ? "#4d8" : "#777",
              padding: "6px 12px", fontSize: 11, cursor: "pointer", borderRadius: 3,
            }}>{v.label}</button>
          ))}
        </div>
        {apiCfg.provider !== "off" && (() => {
          const preset = API_PRESETS[apiCfg.provider];
          return <>
            <div style={{ color: "#555", fontSize: 10, marginBottom: 10 }}>{preset?.note}</div>
            {/* API Key */}
            <div style={{ marginBottom: 12 }}>
              <div style={{ color: "#666", fontSize: 10, marginBottom: 4 }}>API 키</div>
              <input value={apiCfg.key} onChange={e => setApiCfg(p => ({ ...p, key: e.target.value }))}
                placeholder={apiCfg.provider === "gemini" ? "AIza..." : apiCfg.provider === "claude" ? "sk-ant-..." : "sk-..."}
                type="password"
                style={{ width: "100%", background: "#0a0a0a", border: "1px solid #222", color: "#ccc", padding: "8px 10px", fontSize: 12, fontFamily: mono, borderRadius: 3, boxSizing: "border-box" }} />
              {apiCfg.provider === "claude" && <div style={{ color: "#a85", fontSize: 9, marginTop: 4 }}>⚠ 브라우저 CORS 제한으로 직접 호출 불가. 프록시 서버 또는 커스텀 엔드포인트 필요.</div>}
            </div>
            {/* Model selector */}
            {preset?.models?.length > 0 ? (
              <div style={{ marginBottom: 12 }}>
                <div style={{ color: "#666", fontSize: 10, marginBottom: 6 }}>모델 선택</div>
                <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
                  {preset.models.map(m => (
                    <button key={m.id} onClick={() => setApiCfg(p => ({ ...p, model: m.id }))} style={{
                      display: "flex", justifyContent: "space-between", alignItems: "center",
                      background: apiCfg.model === m.id ? "#1a2a1a" : "#0a0a0a",
                      border: `1px solid ${apiCfg.model === m.id ? "#2a6" : "#1a1a1a"}`,
                      padding: "8px 12px", borderRadius: 3, cursor: "pointer", textAlign: "left",
                    }}>
                      <div>
                        <span style={{ color: apiCfg.model === m.id ? "#4d8" : "#aaa", fontSize: 12 }}>{m.name}</span>
                        {m.rec && <span style={{ color: "#f59e0b", fontSize: 9, marginLeft: 6 }}>추천</span>}
                      </div>
                      <span style={{ color: "#555", fontSize: 10 }}>{m.desc}</span>
                    </button>
                  ))}
                </div>
              </div>
            ) : (
              /* Custom: manual model + endpoint input */
              <>
                <div style={{ marginBottom: 10 }}>
                  <div style={{ color: "#666", fontSize: 10, marginBottom: 4 }}>모델명</div>
                  <input value={apiCfg.model} onChange={e => setApiCfg(p => ({ ...p, model: e.target.value }))}
                    placeholder="모델 ID 입력"
                    style={{ width: "100%", background: "#0a0a0a", border: "1px solid #222", color: "#ccc", padding: "8px 10px", fontSize: 12, fontFamily: mono, borderRadius: 3, boxSizing: "border-box" }} />
                </div>
                <div style={{ marginBottom: 10 }}>
                  <div style={{ color: "#666", fontSize: 10, marginBottom: 4 }}>엔드포인트</div>
                  <input value={apiCfg.endpoint} onChange={e => setApiCfg(p => ({ ...p, endpoint: e.target.value }))}
                    placeholder="https://api.example.com/v1/chat/completions"
                    style={{ width: "100%", background: "#0a0a0a", border: "1px solid #222", color: "#ccc", padding: "8px 10px", fontSize: 11, fontFamily: mono, borderRadius: 3, boxSizing: "border-box" }} />
                </div>
              </>
            )}
            {/* Test button */}
            {(apiCfg.provider === "claude" || apiCfg.provider === "custom") && preset?.models?.length > 0 && <div style={{ marginBottom: 10 }}>
              <div style={{ color: "#666", fontSize: 10, marginBottom: 4 }}>엔드포인트 {apiCfg.provider === "claude" ? "(프록시 URL)" : ""}</div>
              <input value={apiCfg.endpoint} onChange={e => setApiCfg(p => ({ ...p, endpoint: e.target.value }))}
                placeholder={apiCfg.provider === "claude" ? "https://your-proxy.com/v1/messages" : "https://api.example.com/v1/chat/completions"}
                style={{ width: "100%", background: "#0a0a0a", border: "1px solid #222", color: "#ccc", padding: "8px 10px", fontSize: 11, fontFamily: mono, borderRadius: 3, boxSizing: "border-box" }} />
            </div>}
            <button onClick={async () => {
              try {
                notify("테스트 중...", "info");
                const res = await llmCall("Say 'OK' in Korean. Nothing else.", 1000);
                notify(`✅ 연결 성공: "${res.slice(0,30)}"`, "success");
              } catch (e) {
                notify(`❌ 실패: ${e.message?.slice(0,60) || "연결 오류"}`, "error");
              }
            }} style={{ width: "100%", background: "#1a2a1a", border: "1px solid #2a6", color: "#4d8", padding: "10px", fontSize: 12, cursor: "pointer", borderRadius: 3, marginTop: 4 }}>
              연결 테스트
            </button>
          </>;
        })()}
        {apiCfg.provider === "off" && <div style={{ color: "#444", fontSize: 11, textAlign: "center", padding: "20px 0", lineHeight: 1.8 }}>
          오프라인 모드<br/>
          <span style={{ color: "#555", fontSize: 10 }}>템플릿 스토리로 플레이됩니다</span>
        </div>}
      </ModalOverlay>}

      {/* Top bar */}
      <div className="safe-top" style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: mobile ? "10px 14px" : "10px 16px", borderBottom: "1px solid #131313", fontFamily: mono, fontSize: mobile ? 12 : 11 }}>
        <div style={{ display: "flex", gap: mobile ? 8 : 12, alignItems: "center" }}>
          <span style={{ color: "#444", letterSpacing: 2, fontSize: mobile ? 10 : 11 }}>ANWEM v5</span>
          {apiCfg.provider !== "off" && <span style={{ color: "#2a6", fontSize: 8, marginLeft: 6, opacity: 0.7 }}>● {API_PRESETS[apiCfg.provider]?.label || apiCfg.provider}</span>}
          <span style={{ color: gc + "88", fontSize: mobile ? 10 : 9 }}>{GENRES[genre]?.name}</span>
          <span style={{ color: "#888" }}>{day}<span style={{ color: "#444" }}>/{SEASON_LEN}</span></span>
          {day > 0 && <div style={{ width: mobile ? 40 : 60, height: 3, background: "#1a1a1a", borderRadius: 2, overflow: "hidden" }}>
            <div style={{ width: `${(day / SEASON_LEN) * 100}%`, height: "100%", background: day >= SEASON_LEN - 1 ? "#f87171" : gc, transition: "width .5s" }} />
          </div>}
          {day >= SEASON_LEN - 1 && <span style={{ color: "#f87171", animation: "pulse 1s infinite", fontSize: 9 }}>FINAL</span>}
          {day > 0 && day < SEASON_LEN - 1 && <span style={{ color: "#f87171", animation: "pulse 2s infinite", fontSize: 9 }}>●</span>}
        </div>
        <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
          <span style={{ color: karma <= 100 ? "#f87171" : karma <= 300 ? "#f59e0b" : "#f59e0b", fontSize: mobile ? 13 : 11, animation: karma <= 100 ? "pulse 1s infinite" : "none" }}>업 {karma.toLocaleString()}{karma <= 100 && karma > 0 ? " ⚠" : ""}</span>
          <button onClick={() => setShop(true)} style={{ background: "#111", border: "1px solid #1a1a1a", color: "#777", padding: mobile ? "4px 10px" : "3px 8px", fontSize: mobile ? 11 : 9, cursor: "pointer", fontFamily: mono }}>SHOP</button>
          <button onClick={() => setShowApiCfg(true)} style={{ background: "#111", border: "1px solid #1a1a1a", color: apiCfg.provider !== "off" ? "#2a6" : "#555", padding: mobile ? "4px 8px" : "3px 6px", fontSize: mobile ? 11 : 9, cursor: "pointer" }}>⚙</button>
          <button onClick={() => setDebugMode(p => !p)} style={{ background: debugMode ? "#1a1a0a" : "#111", border: `1px solid ${debugMode ? "#f59e0b33" : "#1a1a1a"}`, color: debugMode ? "#f59e0b" : "#333", padding: mobile ? "4px 8px" : "3px 6px", fontSize: mobile ? 11 : 9, cursor: "pointer" }}>🔧</button>
        </div>
      </div>

      {/* Mobile: Tab nav */}
      {mobile && (
        <div style={{ display: "flex", borderBottom: "1px solid #131313" }}>
          {[["story", "스토리"], ["bet", "베팅"]].map(([k, label]) => (
            <button key={k} onClick={() => setTab(k)} style={{
              flex: 1, padding: "10px 0", background: tab === k ? "#111" : "#0a0a0a",
              border: "none", borderBottom: tab === k ? `2px solid ${gc}` : "2px solid transparent",
              color: tab === k ? "#ccc" : "#555", fontSize: 13, fontFamily: mono, cursor: "pointer",
              letterSpacing: 2, transition: "all .2s",
            }}>
              {label}
              {k === "bet" && myBets.length > 0 && <span style={{ color: "#4ade80", marginLeft: 4, fontSize: 9 }}>({myBets.length})</span>}
              {k === "bet" && betTimer !== null && betTimer > 0 && !betLocked && (
                <span style={{ color: betTimer <= 30 ? "#f87171" : "#f59e0b", marginLeft: 4, fontSize: 9, fontWeight: 700 }}>
                  {Math.floor(betTimer / 60)}:{(betTimer % 60).toString().padStart(2, "0")}
                </span>
              )}
              {k === "bet" && betLocked && <span style={{ color: "#f87171", marginLeft: 4, fontSize: 9 }}>⊘</span>}
            </button>
          ))}
        </div>
      )}

      {/* Main content */}
      {mobile ? (
        <div style={{ flex: 1, display: "flex", flexDirection: "column", minHeight: 0 }}>
          {tab === "story" ? StoryPanel() : BetPanel()}
        </div>
      ) : (
        <div style={{ display: "flex", flex: 1, minHeight: 0 }}>
          <div style={{ flex: 1, display: "flex", flexDirection: "column", borderRight: "1px solid #131313" }}>
            {StoryPanel()}
          </div>
          {BetPanel()}
        </div>
      )}

      {/* Debug Panel */}
      {debugMode && (
        <div style={{ position: "fixed", bottom: 0, left: 0, right: 0, height: "45vh", background: "#0a0a0a", borderTop: "2px solid #333", zIndex: 300, display: "flex", flexDirection: "column", fontFamily: "monospace", fontSize: 11 }}>
          <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "6px 12px", background: "#111", borderBottom: "1px solid #222" }}>
            <span style={{ color: "#f59e0b", fontWeight: 700 }}>🔧 DEBUG CONSOLE ({debugLogs.length})</span>
            <div style={{ display: "flex", gap: 8 }}>
              <button onClick={() => { const txt = debugLogs.map(l => `${l.time} ${l.label}\n${l.data}`).join('\n---\n'); navigator.clipboard.writeText(txt).then(() => alert('복사 완료!')); }} style={{ background: "#1a1a1a", border: "1px solid #555", color: "#0f0", padding: "2px 8px", fontSize: 10, cursor: "pointer" }}>COPY ALL</button>
              <button onClick={() => setDebugLogs([])} style={{ background: "#1a1a1a", border: "1px solid #333", color: "#888", padding: "2px 8px", fontSize: 10, cursor: "pointer" }}>CLEAR</button>
              <button onClick={() => setDebugMode(false)} style={{ background: "#1a0a0a", border: "1px solid #f8717133", color: "#f87171", padding: "2px 8px", fontSize: 10, cursor: "pointer" }}>✕</button>
            </div>
          </div>
          <div style={{ flex: 1, overflow: "auto", padding: 8 }}>
            {debugLogs.map((log, i) => {
              const colors = { send: "#60a5fa", raw: "#a78bfa", ok: "#4ade80", error: "#f87171", warn: "#f59e0b", parse: "#e8a0b4", bet: "#c084fc", info: "#94a3b8" };
              return (
                <div key={i} style={{ marginBottom: 6, borderBottom: "1px solid #1a1a1a", paddingBottom: 4 }}>
                  <div style={{ display: "flex", gap: 8, alignItems: "center", marginBottom: 2 }}>
                    <span style={{ color: "#444", fontSize: 9 }}>{log.time}</span>
                    <span style={{ color: colors[log.type] || "#888", fontWeight: 700, fontSize: 10 }}>{log.label}</span>
                  </div>
                  <pre style={{ color: "#888", margin: 0, whiteSpace: "pre-wrap", wordBreak: "break-all", fontSize: 10, lineHeight: 1.4, maxHeight: 200, overflow: "auto", background: "#0c0c0c", padding: 4, borderRadius: 2 }}>{log.data}</pre>
                </div>
              );
            })}
          </div>
        </div>
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
